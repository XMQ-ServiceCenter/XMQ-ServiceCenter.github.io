<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.2.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css" integrity="sha256-XOqroi11tY4EFQMR9ZYwZWKj5ZXiftSx36RRuC3anlA=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"xmq-servicecenter.github.io","root":"/","images":"/images","scheme":"Pisces","darkmode":false,"version":"8.20.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="基本定义 环  定义 1. \(\,\!\)（环） 如果在一个集合 \(R\) 上指定了加法和乘法运算，并且这两个运算满足： \(\quad\rhd\quad\)\(R\) 关于加法形成交换群， \(\quad\rhd\quad\)乘法满足结合律， \(\quad\rhd\quad\)乘法与加法之间满足分配律， 就说 \(R\) 是一个环（ring）。  通常，加法群">
<meta property="og:type" content="article">
<meta property="og:title" content="环与模">
<meta property="og:url" content="https://xmq-servicecenter.github.io/2024/05/29/ring_and_module/index.html">
<meta property="og:site_name" content="XMQ-维修中心">
<meta property="og:description" content="基本定义 环  定义 1. \(\,\!\)（环） 如果在一个集合 \(R\) 上指定了加法和乘法运算，并且这两个运算满足： \(\quad\rhd\quad\)\(R\) 关于加法形成交换群， \(\quad\rhd\quad\)乘法满足结合律， \(\quad\rhd\quad\)乘法与加法之间满足分配律， 就说 \(R\) 是一个环（ring）。  通常，加法群">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2024-05-29T08:34:18.000Z">
<meta property="article:modified_time" content="2024-06-12T13:30:00.537Z">
<meta property="article:author" content="XMQ">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://xmq-servicecenter.github.io/2024/05/29/ring_and_module/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://xmq-servicecenter.github.io/2024/05/29/ring_and_module/","path":"2024/05/29/ring_and_module/","title":"环与模"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>环与模 | XMQ-维修中心</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">XMQ-维修中心</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-pepo"><a href="/%E8%80%83%E5%89%8D%E9%A2%84%E4%B9%A0" rel="section"><i class="fa fa-th fa-fw"></i>考前预习</a></li>
  </ul>
</nav>




</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E5%AE%9A%E4%B9%89"><span class="nav-number">1.</span> <span class="nav-text">基本定义</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%8E%AF"><span class="nav-number">1.1.</span> <span class="nav-text">环</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%8E%AF%E7%9A%84%E7%90%86%E6%83%B3"><span class="nav-number">1.2.</span> <span class="nav-text">环的理想</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%8E%AF%E4%B8%8A%E7%9A%84%E6%A8%A1"><span class="nav-number">1.3.</span> <span class="nav-text">环上的模</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%90%8C%E6%80%81%E5%9F%BA%E6%9C%AC%E5%AE%9A%E7%90%86"><span class="nav-number">1.4.</span> <span class="nav-text">同态基本定理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A8%A1%E7%9A%84%E7%9B%B4%E5%92%8C"><span class="nav-number">1.5.</span> <span class="nav-text">模的直和</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8D%87%E9%99%8D%E9%93%BE%E6%9D%A1%E4%BB%B6"><span class="nav-number">1.6.</span> <span class="nav-text">升降链条件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%90%88%E6%88%90%E5%88%97"><span class="nav-number">1.7.</span> <span class="nav-text">合成列</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#zorn-%E5%BC%95%E7%90%86"><span class="nav-number">1.8.</span> <span class="nav-text">Zorn 引理</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%95%B4%E7%8E%AF%E4%B8%8A%E7%9A%84%E5%9B%A0%E5%BC%8F%E5%88%86%E8%A7%A3"><span class="nav-number">2.</span> <span class="nav-text">整环上的因式分解</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B4%E6%95%B0%E7%8E%AF%E4%B8%8A%E7%9A%84%E8%B4%9D%E7%A5%96%E5%AE%9A%E7%90%86"><span class="nav-number">2.1.</span> <span class="nav-text">整数环上的贝祖定理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%94%AF%E4%B8%80%E5%88%86%E8%A7%A3%E6%95%B4%E7%8E%AF"><span class="nav-number">2.2.</span> <span class="nav-text">唯一分解整环</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%BB%E7%90%86%E6%83%B3%E6%95%B4%E7%8E%AF%E4%B8%8E%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E7%8E%AF"><span class="nav-number">2.3.</span> <span class="nav-text">主理想整环与欧几里得环</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%BB%E7%90%86%E6%83%B3%E6%95%B4%E7%8E%AF%E4%B8%8A%E7%9A%84%E6%9C%89%E9%99%90%E7%94%9F%E6%88%90%E6%A8%A1"><span class="nav-number">3.</span> <span class="nav-text">主理想整环上的有限生成模</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%89%AD%E6%A8%A1%E6%97%A0%E6%89%AD%E6%A8%A1%E4%B8%8E%E8%87%AA%E7%94%B1%E6%A8%A1"><span class="nav-number">3.1.</span> <span class="nav-text">扭模、无扭模与自由模</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%BB%E7%90%86%E6%83%B3%E6%95%B4%E7%8E%AF%E4%B8%8A%E6%9C%89%E9%99%90%E7%94%9F%E6%88%90%E6%A8%A1%E7%9A%84%E7%BB%93%E6%9E%84"><span class="nav-number">3.2.</span> <span class="nav-text">主理想整环上有限生成模的结构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%93%E6%9E%84%E5%AE%9A%E7%90%86%E7%9A%84%E5%BA%94%E7%94%A8%E6%9C%89%E9%99%90%E7%94%9F%E6%88%90%E4%BA%A4%E6%8D%A2%E7%BE%A4%E7%9A%84%E7%BB%93%E6%9E%84"><span class="nav-number">3.3.</span> <span class="nav-text">结构定理的应用：有限生成交换群的结构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%93%E6%9E%84%E5%AE%9A%E7%90%86%E7%9A%84%E5%BA%94%E7%94%A8%E7%9F%A9%E9%98%B5%E7%9A%84-jordan-%E6%A0%87%E5%87%86%E5%9E%8B"><span class="nav-number">3.4.</span> <span class="nav-text">结构定理的应用：矩阵的
Jordan 标准型</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8D%8A%E5%8D%95%E7%8E%AF%E7%9A%84%E7%BB%93%E6%9E%84"><span class="nav-number">4.</span> <span class="nav-text">半单环的结构</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B9%82%E7%AD%89%E5%85%83%E4%B8%8E%E5%B9%82%E9%9B%B6%E5%85%83"><span class="nav-number">4.1.</span> <span class="nav-text">幂等元与幂零元</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#jacobson-%E6%A0%B9"><span class="nav-number">4.2.</span> <span class="nav-text">Jacobson 根</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8D%8A%E5%8D%95%E7%8E%AF%E7%9A%84%E7%AD%89%E4%BB%B7%E5%88%BB%E7%94%BB"><span class="nav-number">4.3.</span> <span class="nav-text">半单环的等价刻画</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BE%A4%E4%BB%A3%E6%95%B0"><span class="nav-number">4.4.</span> <span class="nav-text">群代数</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8F%82%E8%80%83%E4%B9%A6%E7%B1%8D"><span class="nav-number">5.</span> <span class="nav-text">参考书籍</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">XMQ</p>
  <div class="site-description" itemprop="description">奇怪的小网站</div>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://xmq-servicecenter.github.io/2024/05/29/ring_and_module/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="XMQ">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="XMQ-维修中心">
      <meta itemprop="description" content="奇怪的小网站">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="环与模 | XMQ-维修中心">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          环与模
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-05-29 16:34:18" itemprop="dateCreated datePublished" datetime="2024-05-29T16:34:18+08:00">2024-05-29</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-06-12 21:30:00" itemprop="dateModified" datetime="2024-06-12T21:30:00+08:00">2024-06-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E8%80%83%E5%89%8D%E9%A2%84%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">考前预习</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E8%80%83%E5%89%8D%E9%A2%84%E4%B9%A0/%E7%BE%A4%E8%AE%BA/" itemprop="url" rel="index"><span itemprop="name">群论</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><hr />
<h1 id="基本定义">基本定义</h1>
<h2 id="环">环</h2>
<div id="ring" class="statement definition plain">
<p><span class="statement-heading"><span class="statement-label">定义
1</span>.</span><span class="statement-spah"> </span><span
class="math inline">\(\,\!\)</span><strong>（环）</strong><br />
如果在一个集合 <span class="math inline">\(R\)</span>
上指定了加法和乘法运算，并且这两个运算满足：<br />
<span class="math inline">\(\quad\rhd\quad\)</span><span
class="math inline">\(R\)</span> 关于加法形成交换群，<br />
<span
class="math inline">\(\quad\rhd\quad\)</span>乘法满足结合律，<br />
<span
class="math inline">\(\quad\rhd\quad\)</span>乘法与加法之间满足分配律，<br />
就说 <span class="math inline">\(R\)</span>
是一个<strong>环（ring）</strong>。</p>
</div>
<p>通常，加法群的零元记为 <span class="math inline">\(0\)</span>。<br />
如果乘法还满足交换律就说 <span class="math inline">\(R\)</span>
是一个<strong>交换环</strong>。<br />
如果乘法有单位元，就说这是一个<strong>幺环</strong>，此时乘法的单位元通常记为
<span class="math inline">\(1\)</span>。</p>
<div id="domain" class="statement definition plain">
<p><span class="statement-heading"><span class="statement-label">定义
2</span>.</span><span class="statement-spah"> </span><span
class="math inline">\(\,\!\)</span><strong>（零因子与整环）</strong><br />
(1)<span class="math inline">\(\quad\)</span>在环中如果有 <span
class="math inline">\(ab=0\)</span>，就说 <span
class="math inline">\(a\)</span>
是环的一个<strong>左零因子</strong>，<span
class="math inline">\(b\)</span>
是一个<strong>右零因子</strong>。左右零因子统称<strong>零因子</strong>。<br />
(2)<span class="math inline">\(\quad\)</span>零因子只有 <span
class="math inline">\(0\)</span> 的交换幺环称为<strong>整环（integral
domain）</strong>。</p>
</div>
<p>零因子只有 <span class="math inline">\(0\)</span> 意味着：如果 <span
class="math inline">\(ab=0\)</span> 那么其中必有一个为 <span
class="math inline">\(0\)</span>；同时这也意味着：如果 <span
class="math inline">\(ac=bc\)</span> 并且 <span
class="math inline">\(c\neq0\)</span>，就必然有 <span
class="math inline">\(a=b\)</span>。因此，整环上的乘法满足消去律。</p>
<p>整数环 <span class="math inline">\(\mathbb Z\)</span>
与数域上的多项式环如 <span class="math inline">\(\mathbb R[x]\)</span>
是整环，但矩阵环不是整环。更多整环的例子留在后面。</p>
<div id="field" class="statement definition plain">
<p><span class="statement-heading"><span class="statement-label">定义
3</span>.</span><span class="statement-spah"> </span><span
class="math inline">\(\,\!\)</span><strong>（体，域）</strong><br />
(1)<span class="math inline">\(\quad\)</span>如果一个幺环中除了 <span
class="math inline">\(0\)</span>
之外的所有元素都有乘法逆元，即幺环中除了 <span
class="math inline">\(0\)</span>
以外的元素关于乘法也成群，那么就说这个幺环是一个<strong>除环（division
ring）</strong>或<strong>体</strong>。<br />
(2)<span
class="math inline">\(\quad\)</span>如果一个除环同时还是交换环，就说这个环是一个<strong>域（field）</strong>。域也可以定义为除了
<span class="math inline">\(0\)</span>
之外的所有元素都有乘法逆元的整环。</p>
</div>
<p>除环中不可能有 <span class="math inline">\(0\)</span>
以外的零因子：如果 <span class="math inline">\(ab=0\)</span> 且 <span
class="math inline">\(a\neq 0\)</span>，那么 <span
class="math inline">\(b=a^{-1}ab=0\)</span>。<br />
除环或体中最重要的例子是<strong>四元数（quaternion） <span
class="math inline">\(\mathbb H\)</span></strong>：</p>
<div id="quaternion" class="statement example definition unnumbered">
<p><span class="statement-heading"><span
class="statement-label">例子</span>：</span><span
class="statement-spah"> </span><span
class="math inline">\(\,\!\)</span><strong>（四元数）</strong><br />
四元数是指： <span class="math display">\[\begin{equation}
\mathbb H:=\left\lbrace a+b\mathrm i+c\mathrm j+d\mathrm k:\quad
a,b,c,d\in\mathbb R\right\rbrace  
\label{quaternion}
\end{equation}\]</span> 其中 <span
class="math inline">\(\mathrm{i,j,k}\)</span> 满足： <span
class="math display">\[\begin{align*}
&amp;\mathrm i^2=\mathrm j^2=\mathrm k^2=-1,\\
&amp;\mathrm i\mathrm j=-\mathrm j\mathrm i=\mathrm k,\\
&amp;\mathrm j\mathrm k=-\mathrm k\mathrm j=\mathrm i,\\
&amp;\mathrm k\mathrm i=-\mathrm i\mathrm k=\mathrm j.
\end{align*}\]</span></p>
</div>
<p>关于有限除环和有限整环，有如下定理：</p>
<div id="finite-division" class="statement theorem plain">
<p><span class="statement-heading"><span class="statement-label">定理
1</span>.</span><span class="statement-spah"> </span><span
class="math inline">\(\,\!\)</span><br />
(1)<span class="math inline">\(\quad\)</span>有限整环一定是域。<br />
(2)<span class="math inline">\(\quad\)</span>Wedderburn
定理：有限大小的除环一定是交换的，因而也一定是域。</p>
</div>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        (1) 的证明
    </div>
    <div class='spoiler-content'>
        <p>在有限整环中任取一个非 <span class="math inline">\(0\)</span> 元素
<span class="math inline">\(a\)</span>，考虑 <span
class="math inline">\(a\)</span>
的各阶幂次。由于有限整环只包含有限个元素，所以一定存在一对 <span
class="math inline">\(m,n\)</span> 使得 <span
class="math inline">\(a^{m}=a^{n}\)</span>，于是 <span
class="math inline">\(a^{m-n}=1\)</span>，这意味着 <span
class="math inline">\(a\)</span>
有乘法逆元且乘法逆元还是自己的幂次。</p>

    </div>
</div>
<p>Wedderburn 定理的证明留在后面。</p>
<p>最后，我们研究环主要是为了研究结合代数：</p>
<div id="algebra" class="statement definition plain">
<p><span class="statement-heading"><span class="statement-label">定义
4</span>.</span><span class="statement-spah"> </span><span
class="math inline">\(\,\!\)</span><strong>（结合代数，交换代数，可除代数）</strong><br />
(1)<span
class="math inline">\(\quad\)</span>如果一个环同时还是线性空间，且线性空间中的加法就是环的加法，就说这个环是一个<strong>结合代数</strong>。
结合代数也可以定义为额外指定了一个满足结合律和分配律的乘法的线性空间。<br />
(2)<span
class="math inline">\(\quad\)</span>如果结合代数中的乘法是交换的，就说这是一个<strong>交换代数</strong>。<br />
(3)<span
class="math inline">\(\quad\)</span>如果结合代数同时还是一个除环，就说这是一个<strong>可除代数</strong>。</p>
</div>
<p>四元数、矩阵代数、张量代数、外代数、Grassmann 代数以及 Clifford
代数都是结合代数。</p>
<h2 id="环的理想">环的理想</h2>
<div id="idea1" class="statement definition plain">
<p><span class="statement-heading"><span class="statement-label">定义
5</span>.</span><span class="statement-spah"> </span><span
class="math inline">\(\,\!\)</span><strong>（理想）</strong><br />
(1)<span
class="math inline">\(\quad\)</span>如果一个环的子集关于加法和乘法也成环，就说这个子集是这个环的<strong>子环</strong>。<br />
(2)<span class="math inline">\(\quad\)</span>如果一个环 <span
class="math inline">\(R\)</span> 的子环 <span
class="math inline">\(I\)</span> 满足： <span
class="math inline">\(RI\subset I\)</span> （<span
class="math inline">\(IR\subset I\)</span>），就说 <span
class="math inline">\(I\)</span> 是 <span
class="math inline">\(R\)</span>
的一个<strong>左（右）理想（idea）</strong>。如果一个子环同时为左理想和右理想，就说这个子环是一个<strong>双边理想</strong>。<br />
(3)<span class="math inline">\(\quad\)</span>假设 <span
class="math inline">\(I\)</span> 是环 <span
class="math inline">\(R\)</span> 的双边理想，不难验证，等价类 <span
class="math inline">\([r]:=r+I\)</span>
在以下加法和乘法下也能构成一个环，称为 <span
class="math inline">\(R\)</span> 对 <span
class="math inline">\(I\)</span> 的<strong>商环</strong>，记为 <span
class="math inline">\(R/I\)</span>： <span
class="math display">\[\begin{align*}
(r_1+I)+(r_2+I)&amp;=(r_1+r_2)+I,\\ (r_1+I)(r_2+I)&amp;=r_1r_2+I.
\end{align*}\]</span></p>
</div>
<p>不难发现，对于交换环而言，左理想与右理想都是双边理想。</p>
<p>从幺环 <span class="math inline">\(R\)</span> 的一个子集 <span
class="math inline">\(M\)</span> 出发来构建左理想的常用方法就是计算
<span class="math inline">\(RM=\{rm:\;\;m\in M,\;r\in
R\}\)</span>，这称为由 <span class="math inline">\(M\)</span>
生成的左理想。由一个元素生成的理想称为主理想：</p>
<div id="idea2" class="statement definition plain">
<p><span class="statement-heading"><span class="statement-label">定义
6</span>.</span><span class="statement-spah"> </span><span
class="math inline">\(\,\!\)</span><strong>（主理想）</strong><br />
(1)<span class="math inline">\(\quad\)</span>从环 <span
class="math inline">\(R\)</span> 中任取一个元素 <span
class="math inline">\(a\)</span>，那么 <span
class="math inline">\(RaR\)</span> 显然可以构成 <span
class="math inline">\(R\)</span> 的一个双边理想，称为由 <span
class="math inline">\(a\)</span> 生成的<strong>主理想</strong>，记为
(a)。<br />
(2)<span
class="math inline">\(\quad\)</span>所有理想都是主理想的环称为<strong>主理想环</strong>。</p>
</div>
<p>除了主理想外，另两种重要的理想是素理想与极大理想：</p>
<div id="idea3" class="statement definition plain">
<p><span class="statement-heading"><span class="statement-label">定义
7</span>.</span><span class="statement-spah"> </span><span
class="math inline">\(\,\!\)</span><strong>（素理想与极大理想）</strong><br />
(1)<span class="math inline">\(\quad\)</span>假设 <span
class="math inline">\(I\)</span> 是环 <span
class="math inline">\(R\)</span> 的理想，并且 <span
class="math inline">\(ab\in I\)</span> 能够推出 <span
class="math inline">\(a\in I\)</span> 或 <span
class="math inline">\(b\in I\)</span>，就说 <span
class="math inline">\(I\)</span> 是环 <span
class="math inline">\(R\)</span> 的<strong>素理想</strong>。<br />
(2)<span class="math inline">\(\quad\)</span>假设 <span
class="math inline">\(I\)</span> 是环 <span
class="math inline">\(R\)</span> 的理想。如果除了 <span
class="math inline">\(R\)</span> 以外没有任何一个理想能够以 <span
class="math inline">\(I\)</span> 为子集，就说 <span
class="math inline">\(I\)</span> 是 <span
class="math inline">\(R\)</span> 的一个<strong>极大理想</strong>。如果
<span class="math inline">\(I\)</span> 除了自己和 <span
class="math inline">\(\{0\}\)</span> 以外没有任何一个理想，就说 <span
class="math inline">\(I\)</span> 是 <span
class="math inline">\(R\)</span> 的一个<strong>极小理想</strong>。</p>
</div>
<p>对于除环和域，有如下定理：</p>
<div id="idea-of-field" class="statement theorem plain">
<p><span class="statement-heading"><span class="statement-label">定理
2</span>.</span><span class="statement-spah"> </span><span
class="math inline">\(\,\!\)</span><br />
(1)<span
class="math inline">\(\quad\)</span>除环和域都只有平凡理想，即它们的理想只有
<span class="math inline">\(\{0\}\)</span> 和自己。<br />
(2)<span class="math inline">\(\quad\)</span>如果 <span
class="math inline">\(R\)</span> 是交换幺环，<span
class="math inline">\(I\)</span> 是它的一个极大理想，那么 <span
class="math inline">\(R/I\)</span> 是域。</p>
</div>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        证明
    </div>
    <div class='spoiler-content'>
        <p>(1)<span class="math inline">\(\quad\)</span>假设 <span
class="math inline">\(I\)</span> 是除环或域 <span
class="math inline">\(R\)</span> 的理想。只要 <span
class="math inline">\(a\in I\)</span>，就有 <span
class="math inline">\(a^{-1}a=1\in I\)</span>，进而 <span
class="math inline">\(I\)</span> 只可能为 <span
class="math inline">\(\{1\}\)</span> 和 <span
class="math inline">\(R\)</span>。</p>
<p>(2)<span class="math inline">\(\quad\)</span>只需证明 <span
class="math inline">\(R/I\)</span> 中除了 <span
class="math inline">\([0]\)</span> 以外的任意一个元素都有乘法逆元。从
<span class="math inline">\(R\backslash I\)</span> 中任取一个非零元素
<span class="math inline">\(a\)</span>，那么 <span
class="math inline">\(Ra+I\)</span> 也是 <span
class="math inline">\(R\)</span> 的理想，且与 <span
class="math inline">\(I\)</span> 不同。由于 <span
class="math inline">\(I\)</span> 是极大理想，因此 <span
class="math inline">\(Ra+I=R\)</span>。这意味着只要存在 <span
class="math inline">\(b\in R\)</span> 以及 <span
class="math inline">\(c\in I\)</span> 使得 <span
class="math inline">\(ba+c=1\)</span>，因此 <span
class="math inline">\([b][a]=[1]\)</span>，即 <span
class="math inline">\([a]\)</span> 的乘法逆元为 <span
class="math inline">\([b]\)</span>。</p>

    </div>
</div>
<p>最后：</p>
<div id="idea4" class="statement definition plain">
<p><span class="statement-heading"><span class="statement-label">定义
8</span>.</span><span class="statement-spah"> </span><span
class="math inline">\(\,\!\)</span><strong>（单环）</strong><br />
除了平凡理想（即 <span class="math inline">\(\{0\}\)</span>
和自己）以外没有双边理想的环称为<strong>单环</strong>。</p>
</div>
<p>注意单环也可以有左理想或右理想。</p>
<h2 id="环上的模">环上的模</h2>
<div id="module" class="statement definition plain">
<p><span class="statement-heading"><span class="statement-label">定义
9</span>.</span><span class="statement-spah"> </span><span
class="math inline">\(\,\!\)</span><strong>（左模）</strong><br />
选取一个环 <span
class="math inline">\(R\)</span>，再选取一个有加法并且关于加法形成交换群的集合
<span class="math inline">\(V\)</span>。如果能够指定 <span
class="math inline">\(R\)</span> 在 <span
class="math inline">\(V\)</span> 上的环作用——即存在一个从 <span
class="math inline">\(R\times V\)</span> 到 <span
class="math inline">\(V\)</span> 的映射，它将 <span
class="math inline">\((r,v)\)</span> 映射为 <span
class="math inline">\(rv\)</span>——并且这个作用还满足对任意的 <span
class="math inline">\(r,r_1,r_2\in R\)</span> 与 <span
class="math inline">\(v,v_1,v_2\in V\)</span> 都有：<br />
<span class="math inline">\(\quad\rhd\quad\)</span> <span
class="math inline">\(r_1(r_2v)=(r_1r_2)v,\)</span><br />
<span class="math inline">\(\quad\rhd\quad\)</span> <span
class="math inline">\((r_1+r_2)v=r_1v+r_2v,\)</span><br />
<span class="math inline">\(\quad\rhd\quad\)</span> <span
class="math inline">\(r(v_1+v_2)=rv_1+rv_2,\)</span><br />
就说 <span class="math inline">\(V\)</span> 是 <span
class="math inline">\(R\)</span>
的一个<strong>左模（module）</strong>，或者左 <span
class="math inline">\(R\)</span>-模。</p>
</div>
<p>在左模的定义中，将第一条改为 <span
class="math inline">\(r_1(r_2v)=(r_2r_1)v\)</span>
就能得到右模（此时最好将 <span class="math inline">\(rv\)</span> 记为
<span class="math inline">\(vr\)</span>），但我们一般只关心左模。</p>
<p>不难想象，交换群构成 <span class="math inline">\(\mathbb Z\)</span>
的左模，<span class="math inline">\(\mathbb Z\)</span> 中的元素 <span
class="math inline">\(n\)</span> 在交换群群元 <span
class="math inline">\(g\)</span> 上的作用 <span
class="math inline">\(ng\)</span> 就是将 <span
class="math inline">\(n\)</span> 个 <span
class="math inline">\(g\)</span> 相加。数域 <span
class="math inline">\(\mathbb F\)</span> 上的线性空间 <span
class="math inline">\(V\)</span> 也构成 <span
class="math inline">\(\mathbb F\)</span> 的左模，<span
class="math inline">\(\mathbb F\)</span> 在 <span
class="math inline">\(V\)</span>
上的作用就是线性空间中的数乘。更多模的例子留在后面。</p>
<div id="simple-module" class="statement definition plain">
<p><span class="statement-heading"><span class="statement-label">定义
10</span>.</span><span class="statement-spah"> </span><span
class="math inline">\(\,\!\)</span><strong>（子模，单模等等）</strong><br />
(1)<span class="math inline">\(\quad\)</span>如果 <span
class="math inline">\(V\)</span> 是左 <span
class="math inline">\(R\)</span>-模，并且 <span
class="math inline">\(V_1\subset V\)</span> 也构成 <span
class="math inline">\(R\)</span> 的左模，就说 <span
class="math inline">\(V_1\)</span> 是 <span
class="math inline">\(V\)</span> 的<strong>左子模</strong>。<br />
(2)<span class="math inline">\(\quad\)</span>如果左 <span
class="math inline">\(R\)</span>-模 <span
class="math inline">\(V\)</span> 有左子模 <span
class="math inline">\(V_1\)</span>，那么等价类 <span
class="math inline">\([v]:=v+V_1\)</span> 在以下环作用下也能构成一个
<span class="math inline">\(R\)</span> 模：<span
class="math inline">\(r(v+V_1):=rv+V_1\)</span>。这样的模称为<strong>商模</strong>，记为
<span class="math inline">\(V/V_1\)</span>。<br />
(3)<span
class="math inline">\(\quad\)</span>如果一个左模没有左子模，就说这个模是<strong>左单（simple）模</strong>。<br />
(4)<span class="math inline">\(\quad\)</span>如果一个左 <span
class="math inline">\(R\)</span>-模 <span
class="math inline">\(V\)</span> 满足 <span
class="math inline">\(V=Rv\)</span>，其中 <span
class="math inline">\(v\in V\)</span>，就说 <span
class="math inline">\(V\)</span> 是由 <span
class="math inline">\(v\)</span> 生成的<strong>循环模</strong>。</p>
</div>
<p>单模是很简单的：假设 <span class="math inline">\(V\)</span> 是一个左
<span class="math inline">\(R\)</span>-模， <span
class="math inline">\(v\)</span> 是 <span
class="math inline">\(V\)</span> 中的非零元，那么循环模 <span
class="math inline">\(Rv\)</span> 将构成 <span
class="math inline">\(V\)</span> 的子模。如果 <span
class="math inline">\(V\)</span> 是左单模就意味着 <span
class="math inline">\(V=Rv\)</span>，因此左单模就是任意一个非零元 <span
class="math inline">\(v\)</span> 生成的循环模。</p>
<p>环 <span class="math inline">\(R\)</span>
可以构成自己的左模，这只需要在上述模的定义中将 <span
class="math inline">\(rv\)</span> 视为环乘法即可。我们用 <span
class="math inline">\(_RR\)</span> 表示作为自己的左模的环 <span
class="math inline">\(R\)</span>。在这个意义下，环的左理想就是自己的左子模。左单环就是那些作为自己的左模是单模的环。显然，左单环没有左理想。</p>
<p><span id="quotient-module-on-quotient-ring"></p>
<p>如果 <span class="math inline">\(V\)</span> 是左 <span
class="math inline">\(R\)</span>-模，<span
class="math inline">\(I\)</span> 是 <span
class="math inline">\(R\)</span> 的双边理想，那么不难证明 <span
class="math display">\[IV:=\left\lbrace\sum_{s\in S} r_sv_s:\quad r_s\in
I,\;v_s\in V\right\rbrace\]</span> 是 <span
class="math inline">\(V\)</span> 的一个子模，并且商模 <span
class="math inline">\(V/IV\)</span> 同时也可视为商环 <span
class="math inline">\(R/I\)</span> 上的模，其中的环作用为： <span
class="math display">\[(r+I)(v+IV)=rv+IV.\]</span> <div class='spoiler collapsed'>
    <div class='spoiler-title'>
        跳转到
    </div>
    <div class='spoiler-content'>
        <p><a href="#PID-finite-generated-module-3">初等因子分解</a></p>

    </div>
</div></p>
<p></span></p>
<h2 id="同态基本定理">同态基本定理</h2>
<p>群、环、域、模都有自己的同态与同态基本定理，其结论与证明思路大同小异。此处以模同态为例说明同态的定义与同态基本定理。</p>
<div id="module-homomorphism" class="statement definition plain">
<p><span class="statement-heading"><span class="statement-label">定义
11</span>.</span><span class="statement-spah"> </span><span
class="math inline">\(\,\!\)</span><strong>（模同态）</strong><br />
假设 <span class="math inline">\(M\)</span> 与 <span
class="math inline">\(N\)</span> 是两个左 <span
class="math inline">\(R\)</span>-模，<span
class="math inline">\(\varphi\)</span> 是一个从 <span
class="math inline">\(M\)</span> 到 <span
class="math inline">\(N\)</span> 的映射。<br />
(1)<span class="math inline">\(\quad\)</span>如果 <span
class="math inline">\(\varphi\)</span> 满足：<br />
<span class="math inline">\(\quad\rhd\quad\)</span> <span
class="math inline">\(\varphi(m_1+m_2)=\varphi(m_1)+\varphi(m_2),\quad
m_{1,2}\in M\)</span><br />
<span class="math inline">\(\quad\rhd\quad\)</span> <span
class="math inline">\(\varphi(rm)=r\varphi(m),\quad m\in M,\;r\in
R.\)</span><br />
就说 <span class="math inline">\(\varphi\)</span> 是一个从 <span
class="math inline">\(M\)</span> 到 <span
class="math inline">\(N\)</span>
的<strong>模同态（homomorphism）</strong>，<span
class="math inline">\(M\)</span> 与 <span
class="math inline">\(N\)</span> 之间全体模同态也可构成模，记为 <span
class="math inline">\(\mathrm{Hom}_R(M,N)\)</span>。<span
class="math inline">\(\mathrm{Hom}_R(M,M)\)</span> 可以形成环，称为
<span class="math inline">\(M\)</span> 的自同态环，记为 <span
class="math inline">\(\mathrm{End}_R(M)\)</span>。<br />
(2)<span class="math inline">\(\quad\)</span>集合 <span
class="math inline">\(\mathrm{ker}\,\varphi=\{x\in M:\quad
\varphi(x)=0\in N\}\)</span>
称为模同态的<strong>核（kernel）</strong>，集合 <span
class="math inline">\(\mathrm{im}\,\varphi=\{x\in N:\quad\)</span> 存在
<span class="math inline">\(y\in M\)</span> 使得 <span
class="math inline">\(x=\varphi(y)\}\)</span>
称为同态的<strong>像（image）</strong>。<br />
(3)<span
class="math inline">\(\quad\)</span>如果一个模同态是一一映射，那么就说这个模同态就称为模同构。如果两个模
<span class="math inline">\(M,N\)</span>
之间存在模同构（isomorphism），就说这两个模是<strong>同构</strong>的，记为
<span class="math inline">\(M\simeq N\)</span>。</p>
</div>
<p>关于模同态，有如下三个同态基本定理：</p>
<div id="homomorphism-theorem" class="statement theorem plain">
<p><span class="statement-heading"><span class="statement-label">定理
3</span>.</span><span class="statement-spah"> </span><span
class="math inline">\(\,\!\)</span><strong>（同态基本定理）</strong><br />
假设 <span class="math inline">\(M,M&#39;\)</span> 都是 <span
class="math inline">\(R\)</span>-模，<span
class="math inline">\(H,N\)</span> 是 <span
class="math inline">\(M\)</span> 的两个子模，<span
class="math inline">\(\varphi\in\mathrm{Hom}_R(M,M&#39;)\)</span>。<br />
(1)<span class="math inline">\(\quad\)</span>同态基本定理：<span
class="math inline">\(\mathrm{im}\,\varphi\)</span> 是一个模，<span
class="math inline">\(\mathrm{ker}\,\varphi\)</span> 是 <span
class="math inline">\(M\)</span> 的子模，并且有： <span
class="math display">\[M/\mathrm{ker}\,\varphi\simeq
\mathrm{im}\,\varphi.\]</span> (2)<span
class="math inline">\(\quad\)</span>第二同态定理：<span
class="math inline">\(H\cap N\)</span> 与 <span
class="math inline">\(N\)</span> 是 <span
class="math inline">\(H\)</span> 与 <span
class="math inline">\(H+N\)</span> 的子模，并且有： <span
class="math display">\[H/(H\cap N)\simeq (H+N)/N.\]</span> (3)<span
class="math inline">\(\quad\)</span>第三同态定理：如果 <span
class="math inline">\(T\)</span> 是 <span
class="math inline">\(H\)</span> 的子模，那么： <span
class="math display">\[(M/T)/(H/T)\simeq M/H.\]</span></p>
</div>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        证明
    </div>
    <div class='spoiler-content'>
        <p>(1)<span class="math inline">\(\quad\)</span>任取 <span
class="math inline">\(m_{1,2}\in \mathrm{ker}\,\varphi\)</span>，<span
class="math inline">\(r\in R\)</span>。由于 <span
class="math inline">\(\varphi(m_1+m_2)=\varphi(m_1)+\varphi(m_2)=0\)</span>，<span
class="math inline">\(\varphi(rm_1)=r\varphi(m_1)=0\)</span>，这意味着
<span class="math inline">\(m_1+m_2\in
\mathrm{ker}\,\varphi\)</span>，<span class="math inline">\(rm_1\in
\mathrm{ker}\,\varphi\)</span>。所以 <span
class="math inline">\(\mathrm{ker}\,\varphi\)</span> 确实构成一个 <span
class="math inline">\(R\)</span>-模。</p>
<p>任取 <span class="math inline">\(n_{1,2}\in
\mathrm{im}\,\varphi\)</span>，并且 <span
class="math inline">\(n_{1,2}=\varphi(m_{1,2})\)</span>，再任取 <span
class="math inline">\(r\in R\)</span>。由于 <span
class="math inline">\(n_1+n_2=\varphi(m_1)+\varphi(m_2)=\varphi(m_1+m_2)\)</span>，<span
class="math inline">\(rn_1=r\varphi(m_1)=\varphi(rm_1)\)</span>，这意味着
<span class="math inline">\(n_1+n_2\in
\mathrm{im}\,\varphi\)</span>，<span class="math inline">\(rn_1\in
\mathrm{im}\,\varphi\)</span>。所以 <span
class="math inline">\(\mathrm{im}\,\varphi\)</span> 确实构成一个 <span
class="math inline">\(R\)</span>-模。</p>
<p>现在考虑从商模 <span
class="math inline">\(M/\mathrm{ker}\,\varphi\)</span> 到 <span
class="math inline">\(\mathrm{im}\,\varphi\)</span> 的映射 <span
class="math inline">\(\varphi&#39;\)</span>： <span
class="math display">\[\varphi&#39;(\bar m):=\varphi(m),\quad \bar
m=m+\mathrm{ker}\,\varphi\in M/\mathrm{ker}\,\varphi.\]</span>
不难证明这一映射是 well-defined 的，因为 <span
class="math inline">\(\varphi(\mathrm{ker}\,\varphi)=0\)</span>。<br />
然后证明这一映射是单射：如果 <span class="math inline">\(\bar m_1\neq
\bar m_2\)</span> 但 <span class="math inline">\(\varphi&#39;(\bar
m_1)=\varphi&#39;(\bar m_2)\)</span>，那么 <span
class="math inline">\(\varphi&#39;(\bar m_1-\bar
m_2)=\varphi(m_1-m_2)=0\)</span>，这意味着 <span
class="math inline">\(m_1-m_2\in \mathrm{ker}\,\varphi\)</span>，这与
<span class="math inline">\(\bar m_1\neq \bar m_2\)</span> 矛盾。
这一映射显然是满射，所以这一映射是一一映射，因而是同构。</p>
<hr />
<p>(2)<span class="math inline">\(\quad\)</span>不难看出，<span
class="math inline">\(H\cap N\)</span> 与 <span
class="math inline">\(N\)</span> 确实是 <span
class="math inline">\(H\)</span> 与 <span
class="math inline">\((H+N)\)</span> 的子模。然后考虑从 <span
class="math inline">\((H+N)\)</span> 到 <span
class="math inline">\(H/(H\cap N)\)</span> 的映射 <span
class="math inline">\(\phi\)</span>： <span
class="math display">\[\phi(h+n)=\bar h:=h+H\cap N,\quad h\in H,\quad
n\in N.\]</span> 首先证明这一映射是 well-defined 的：如果 <span
class="math inline">\(h_1+n_1=h_2+n_2\)</span>，那么 <span
class="math inline">\(h_1-h_2=n_2-n_1\)</span>，前者是 <span
class="math inline">\(H\)</span> 中的元素，后者是 <span
class="math inline">\(N\)</span> 中的元素，因此 <span
class="math inline">\(h_1-h_2=n_2-n_1\in H\cap N\)</span>，这也意味着
<span class="math inline">\(\bar h_1=\bar h_2\)</span>。</p>
<p>然后证明这一映射是模同态： <span
class="math display">\[\begin{align*}
\phi((h_1+n_1)+(h_2+n_2))&amp;=\phi(h_1+h_2+n_1+n_2)=h_1+h_2+H\cap N\\
&amp;=\phi(h_1+n_1)+\phi(h_2+n_2),
\end{align*}\]</span> 以及 <span class="math display">\[\begin{align*}
\phi(r(h_1+n_1))&amp;=rh_1+H\cap N=r(h_1+H\cap N)=r\phi(h_1+n_1).
\end{align*}\]</span></p>
<p>不难证明 <span class="math inline">\(\phi\)</span> 的同态核是 <span
class="math inline">\(N\)</span>，而同态像为 <span
class="math inline">\(H/(H\cap N)\)</span>，因此 <span
class="math inline">\((H+N)/N\simeq H/(H\cap N)\)</span>。</p>
<hr />
<p>(3)<span class="math inline">\(\quad\)</span>考虑从 <span
class="math inline">\(M/T\)</span> 到 <span
class="math inline">\(M/H\)</span> 的映射： <span
class="math display">\[\eta(m+T)=m+H.\]</span> 先证明这一映射是
well-defined 的：如果 <span
class="math inline">\(m_1+T=m_2+T\)</span>，那么 <span
class="math inline">\(m_1-m_2\in T\)</span>，而 <span
class="math inline">\(T\subset H\)</span>，因此 <span
class="math inline">\(m_1-m_2\in H\)</span>，所以 <span
class="math inline">\(m_1+H=m_2+H\)</span>。</p>
<p>然后证明 <span class="math inline">\(\eta\)</span> 是模同态： <span
class="math display">\[\begin{align*}
\eta(m_1+T+m_2+T)&amp;=m_1+m_2+H=m_1+H+m_2+H\\
&amp;=\eta(m_1+T)+\eta(m_2+T),
\end{align*}\]</span> 以及 <span class="math display">\[\begin{align*}
\eta(rm+T)&amp;=rm+H=r(m+H)=r\eta(m+T).
\end{align*}\]</span> 显然，同态核是 <span
class="math inline">\(H/T\)</span>，同态像是 <span
class="math inline">\(M/H\)</span>，因此 <span
class="math inline">\((M/T)/(H/T)\simeq M/H\)</span>。</p>

    </div>
</div>
<p>关于单模之间的环同态，有 Schur 引理：</p>
<div id="Schur-lemma" class="statement theorem plain">
<p><span class="statement-heading"><span class="statement-label">定理
4</span>.</span><span class="statement-spah"> </span><span
class="math inline">\(\,\!\)</span><strong>（Schur 引理）</strong><br />
假设 <span class="math inline">\(M,N\)</span> 是两个左 <span
class="math inline">\(R\)</span>-模，并且都是单模。那么 <span
class="math inline">\(M,N\)</span> 同构时 <span
class="math inline">\(\mathrm{Hom}_R(M,N)\)</span> 是除环，<span
class="math inline">\(M,N\)</span> 不同构时 <span
class="math inline">\(\mathrm{Hom}_R(M,N)=\{0\}\)</span>。</p>
</div>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        证明
    </div>
    <div class='spoiler-content'>
        <p>从 <span class="math inline">\(\mathrm{Hom}_R(M,N)\)</span>
中任取一个非零映射 <span class="math inline">\(f\)</span>，由于 <span
class="math inline">\(\mathrm{ker}\,f\)</span> 是 <span
class="math inline">\(M\)</span> 的子模，因此 <span
class="math inline">\(\mathrm{ker}\,f=M\)</span> 或 <span
class="math inline">\(\{0\}\)</span>。同态像 <span
class="math inline">\(\mathrm{im}\,f\)</span> 是 <span
class="math inline">\(N\)</span> 的子模，因此 <span
class="math inline">\(\mathrm{im}\,f=\{0\}\)</span> 或 <span
class="math inline">\(N\)</span>。</p>
<p><span class="math inline">\(\mathrm{ker}\,f=M\)</span> 或 <span
class="math inline">\(\mathrm{im}\,f=\{0\}\)</span> 都意味着 <span
class="math inline">\(f=0\)</span>。<span
class="math inline">\(\mathrm{ker}\,f=\{0\}\)</span> 且 <span
class="math inline">\(\mathrm{im}\,f=N\)</span> 意味着 <span
class="math inline">\(M\simeq N\)</span>。</p>
<p>如果 <span class="math inline">\(M\)</span> 与 <span
class="math inline">\(N\)</span> 不同构，就只有 <span
class="math inline">\(f=0\)</span> 一种情况。如果 <span
class="math inline">\(M\simeq N\)</span>，那么除了 <span
class="math inline">\(0\)</span> 以外，<span
class="math inline">\(\mathrm{Hom}_R(M,N)\)</span>
内的元素都是同构，因此必然有逆元，所以 <span
class="math inline">\(\mathrm{Hom}_R(M,N)\)</span> 是除环。</p>

    </div>
</div>
<h2 id="模的直和">模的直和</h2>
<div id="direct-sum-module" class="statement definition plain">
<p><span class="statement-heading"><span class="statement-label">定义
12</span>.</span><span class="statement-spah"> </span><span
class="math inline">\(\,\!\)</span><strong>（模的直和）</strong><br />
(1)<span class="math inline">\(\quad\)</span>假设 <span
class="math inline">\(M_1\sim M_n\)</span> 是 <span
class="math inline">\(n\)</span> 个 <span
class="math inline">\(R\)</span>-模，在集合 <span
class="math display">\[M_1\times\cdots\times
M_n=\{(x_1,\cdots,x_n):\quad x_i\in M_i\}\]</span> 中定义加法和环作用：
<span class="math display">\[\begin{align*}
(x_1,\cdots,x_n)+(y_1,\cdots,y_n)&amp;=(x_1+y_1,\cdots,x_n+y_n),\\
r(y_1,\cdots,y_n)&amp;=(ry_1,\cdots,ry_n),
\end{align*}\]</span> 那么 <span
class="math inline">\(M_1\times\cdots\times M_n\)</span> 也能构成 <span
class="math inline">\(R\)</span>-模，称为 <span
class="math inline">\(M_1\sim M_n\)</span> 的<strong>直和</strong>，记为
<span class="math inline">\(M_1\oplus\cdots\oplus M_n\)</span> 或 <span
class="math inline">\(\displaystyle\bigoplus_{i=1}^nM_i\)</span>.<br />
(2)<span class="math inline">\(\quad\)</span>如果 <span
class="math inline">\(M_1\sim M_n\)</span> 是 <span
class="math inline">\(R\)</span>-模 <span
class="math inline">\(M\)</span> 的子模，并且 <span
class="math inline">\(M\simeq M_1\oplus\cdots\oplus M_n\)</span>，就说
<span class="math inline">\(M\)</span> 是 <span
class="math inline">\(M_1\sim M_n\)</span> 的内直和，也称直和。</p>
</div>
<p>可以证明：</p>
<div id="direct-sum-theorem" class="statement theorem plain">
<p><span class="statement-heading"><span class="statement-label">定理
5</span>.</span><span class="statement-spah"> </span><span
class="math inline">\(\,\!\)</span> 模 <span
class="math inline">\(M\)</span> 是子模 <span
class="math inline">\(M_1\sim M_n\)</span> 的直和当且仅当 <span
class="math inline">\(M=M_1+\cdots+M_n\)</span> 并且 <span
class="math inline">\(M_i\cap\left(\displaystyle\bigoplus_{n\neq
i}M_j\right)=\{0\}\)</span>。</p>
</div>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        证明
    </div>
    <div class='spoiler-content'>
        <p>只证明“<span class="math inline">\(\Leftarrow\)</span>”。只证明 <span
class="math inline">\(M\)</span> 中的元素可被唯一地写为 <span
class="math inline">\(m_1+\cdots+m_n\)</span>，其中 <span
class="math inline">\(m_i\in
M_i\)</span>。证明思路为数学归纳法。关键步骤如下：<br />
假设 <span class="math inline">\(M=N+M&#39;\)</span>，<span
class="math inline">\(N\cap M&#39;=\{0\}\)</span>。假设 <span
class="math inline">\(m\in M\)</span> 有两种表示方法：<span
class="math inline">\(m=n_1+m_1&#39;=n_2+m_2&#39;\)</span>，那么 <span
class="math inline">\(n_1-n_2=m_2&#39;-m_1&#39;\)</span>，前者在 <span
class="math inline">\(N\)</span> 中，后者在 <span
class="math inline">\(M&#39;\)</span> 中，因此 <span
class="math inline">\(n_1-n_2=m_2&#39;-m_1&#39;=0\)</span>，这意味着
<span class="math inline">\(m\)</span> 的表示是唯一的。</p>

    </div>
</div>
<h2 id="升降链条件">升降链条件</h2>
<div id="chain-condition" class="statement definition plain">
<p><span class="statement-heading"><span class="statement-label">定义
13</span>.</span><span class="statement-spah"> </span><span
class="math inline">\(\,\!\)</span><strong>（升链条件与降链条件）</strong><br />
(1)<span class="math inline">\(\quad\)</span>如果左 <span
class="math inline">\(R\)</span>-模 <span
class="math inline">\(M\)</span> 的每一个左子模的降链 <span
class="math display">\[M\supsetneq M_1\supsetneq M_2\supsetneq
M_3\supsetneq\cdots\]</span> 都能够终止，即存在一个 <span
class="math inline">\(t\)</span> 使得 <span
class="math inline">\(M_t=M_{t+1}=\cdots\)</span>，就说 <span
class="math inline">\(M\)</span>
满足<strong>降链条件（DCC）</strong>。<br />
(2)<span class="math inline">\(\quad\)</span>如果左 <span
class="math inline">\(R\)</span>-模 <span
class="math inline">\(M\)</span> 的每一个左子模的升链 <span
class="math display">\[M_1\subsetneq M_2\subsetneq
M_3\subsetneq\cdots\]</span> 都能够终止，即存在一个 <span
class="math inline">\(t\)</span> 使得 <span
class="math inline">\(M_t=M_{t+1}=\cdots\)</span>，就说 <span
class="math inline">\(M\)</span>
满足<strong>升链条件（ACC）</strong>。<br />
(3)<span class="math inline">\(\quad\)</span>在以上定义中，将 <span
class="math inline">\(R\)</span> 视为自己的左模 <span
class="math inline">\(_RR\)</span>，将左子模换为左理想，就能得到环的升降链条件。满足降链条件的环称为左
<strong>Artin 环</strong>，满足升链条件的环称为左 <strong>Noether
环</strong>。</p>
</div>
<p>Artinian 与 Northerian 的等价刻画还有：</p>
<div id="chain-condition-theorem1" class="statement theorem plain">
<p><span class="statement-heading"><span class="statement-label">定理
6</span>.</span><span class="statement-spah"> </span><span
class="math inline">\(\,\!\)</span><br />
(1)<span class="math inline">\(\quad\)</span>如果左 <span
class="math inline">\(R\)</span>-模 <span
class="math inline">\(M\)</span> 满足降链条件，那么每一个由 <span
class="math inline">\(M\)</span> 的左子模组成的非空集合 <span
class="math inline">\(\mathcal F\)</span> 内都有一个极小元，即存在 <span
class="math inline">\(S_0\in\mathcal F\)</span> 使得 <span
class="math inline">\(\mathcal F\)</span> 中不会有左子模 <span
class="math inline">\(S\)</span> 满足 <span
class="math inline">\(S\subsetneq S_0\)</span>。<br />
(2)<span class="math inline">\(\quad\)</span>如果左 <span
class="math inline">\(R\)</span>-模 <span
class="math inline">\(M\)</span> 满足升链条件，那么每一个由 <span
class="math inline">\(M\)</span> 的左子模组成的非空集合 <span
class="math inline">\(\mathcal F\)</span> 内都有一个极大元，即存在 <span
class="math inline">\(S_0\in\mathcal F\)</span> 使得 <span
class="math inline">\(\mathcal F\)</span> 中不会有左子模 <span
class="math inline">\(S\)</span> 满足 <span
class="math inline">\(S\supsetneq S_0\)</span>。</p>
</div>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        证明
    </div>
    <div class='spoiler-content'>
        <p>(1)<span class="math inline">\(\quad\)</span>从 <span
class="math inline">\(\mathcal F\)</span> 中选取一个 <span
class="math inline">\(S_1\)</span>，如果 <span
class="math inline">\(S_1\)</span> 是极小元则完成了证明。如果 <span
class="math inline">\(S_1\)</span> 不是极小元，那么存在 <span
class="math inline">\(S_2\)</span> 满足 <span
class="math inline">\(S_2\subsetneq S_1\)</span>。对 <span
class="math inline">\(S_2\)</span>
继续以上过程，如果一直不能找到极小元，就能得到一个左子模的降链 <span
class="math display">\[S_1\supsetneq S_2\supsetneq
S_3\supsetneq\cdots.\]</span>
根据降链条件，这个降链总有结束的一天，其结尾就是极小元。<br />
(2)<span class="math inline">\(\quad\)</span>同理。</p>

    </div>
</div>
<p>Artin 环与 Noether 环相关的例子有：</p>
<div id="Artin-Noether" class="statement example definition unnumbered">
<p><span class="statement-heading"><span
class="statement-label">例子</span>：</span><span
class="statement-spah"> </span><span
class="math inline">\(\,\!\)</span><br />
(1)<span class="math inline">\(\quad\)</span>整数环 <span
class="math inline">\(\mathbb Z\)</span> 是 Noether 环但不是 Artin
环：整数环总有极大理想 <span class="math inline">\((p)\)</span>，其中
<span class="math inline">\(p\)</span> 为素数，因此是 Noether
环。但整数环没有极小理想： <span class="math display">\[(p)\supsetneq
(p^2)\supsetneq (p^3)\supsetneq \cdots.\]</span> (2)<span
class="math inline">\(\quad\)</span>不难想象，结合代数的理想也是线性空间，因此
<span class="math inline">\(n\)</span> 维结合代数的理想的降链最多只有
<span class="math inline">\(n\)</span> 个严格的 <span
class="math inline">\(\supsetneq\)</span>，所以结合代数总是 Artin
环。</p>
</div>
<p>可以证明，Artin 环总是 Noether 环。</p>
<h2 id="合成列">合成列</h2>
<p>此处以环上的模为例说明的合成列相关的定理。</p>
<div id="composition-series" class="statement definition plain">
<p><span class="statement-heading"><span class="statement-label">定义
14</span>.</span><span class="statement-spah"> </span><span
class="math inline">\(\,\!\)</span><strong>（合成列）</strong><br />
假设 <span class="math inline">\(M\)</span> 是一个 <span
class="math inline">\(R\)</span>-模，考虑一个有限长度的、从 <span
class="math inline">\(M\)</span> 开始到 <span
class="math inline">\(\{0\}\)</span> 结束的子模序列 <span
class="math inline">\(\{M_i\}_{i=0}^n\)</span>： <span
class="math display">\[M=M_0\supset M_1\supset M_2\supset\cdots\supset
M_n=\{0\}.\]</span> (1)<span
class="math inline">\(\quad\)</span>子模序列中严格包含出现的次数称为这个序列的长度，<span
class="math inline">\(\{M_i/M_{i+1}\}\)</span>
称为这个序列的因子。<br />
(2)<span class="math inline">\(\quad\)</span>如果另有一个序列 <span
class="math inline">\(\{M_i&#39;\}_{i=0}^{n&#39;}\)</span> 以 <span
class="math inline">\(\{M_i\}_{i=0}^n\)</span> 为子列，就说 <span
class="math inline">\(\{M_i&#39;\}_{i=0}^{n&#39;}\)</span> 是 <span
class="math inline">\(\{M_i\}_{i=0}^n\)</span> 的加细。<br />
(3)<span
class="math inline">\(\quad\)</span>如果一个序列的因子经过重新排列之后能够与另一个序列的因子一一同构，就说这两个序列等价。<br />
(4)<span
class="math inline">\(\quad\)</span>如果一个序列的因子都是单模，就说这个序列是一个<strong>合成列（composition
series）</strong>，合成列的因子称为<strong>合成因子</strong>。</p>
</div>
<p>模也有 Jordan–Hölder 定理，以下逐步证明这一定理。首先是 Zassenhaus
引理。</p>
<div id="Zassenhaus" class="statement theorem plain">
<p><span class="statement-heading"><span class="statement-label">定理
7</span>.</span><span class="statement-spah"> </span><span
class="math inline">\(\,\!\)</span><strong>（Zassenhaus 引理）</strong>
假设 <span class="math inline">\(M\)</span> 是 <span
class="math inline">\(R\)</span> 模，<span
class="math inline">\(A^\ast,B^\ast\)</span> 是 <span
class="math inline">\(M\)</span> 的子模，<span
class="math inline">\(A,B\)</span> 分别是 <span
class="math inline">\(A^\ast,B^\ast\)</span> 的子模，那么： <span
class="math display">\[\dfrac{A+(A^\ast\cap B^\ast)}{A+(A^\ast\cap
B)}\simeq\dfrac{B+(B^\ast\cap A^\ast)}{B+(B^\ast\cap A)}.\]</span></p>
</div>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        证明
    </div>
    <div class='spoiler-content'>
        <p>不难发现，如果 <span class="math inline">\(M_1\)</span> 与 <span
class="math inline">\(M_2\)</span> 是 <span
class="math inline">\(M\)</span> 的子模，那么不难证明 <span
class="math inline">\(M_1\cap M_2\)</span> 是子模，<span
class="math inline">\(M_1+M_2\)</span> 也是子模。</p>
<p>于是，<span class="math inline">\(A+(A^\ast\cap B^\ast)\)</span> 与
<span class="math inline">\(A+(A^\ast\cap B)\)</span>
都是子模，并且后者是前者的子模。</p>
<p>显然，<span class="math inline">\(A\cap B^\ast\)</span> 与 <span
class="math inline">\(A^\ast\cap B\)</span> 是 <span
class="math inline">\(A^\ast\cap B^\ast\)</span> 的子模。并且 <span
class="math inline">\(D:=A\cap B^\ast+A^\ast\cap B\)</span> 也是 <span
class="math inline">\(A^\ast\cap B^\ast\)</span> 的子模。</p>
<p>考虑从 <span class="math inline">\(A+(A^\ast\cap B^\ast)\)</span> 到
<span class="math inline">\((A^\ast\cap B^\ast)/D\)</span> 的映射 <span
class="math inline">\(\varphi\)</span>： <span
class="math display">\[\varphi(a+x)=\bar x:\quad a\in A,\;\;x\in
(A^\ast\cap B^\ast),\;\;\bar x:=x+D.\]</span> 然后证明它是模同态。</p>
<p>先证明这一映射是 Well-defined 的：如果 <span
class="math inline">\(a_1+x_1=a_2+x_2\)</span> 那么 <span
class="math inline">\(a_1-a_2=x_2-x_1\)</span>。<span
class="math inline">\(a_1-a_2\in A\)</span>，<span
class="math inline">\(x_2-x_1\in (A^\ast\cap B^\ast)\)</span>，因此
<span class="math display">\[a_1-a_2=x_2-x_1\in A\cap(A^\ast\cap
B^\ast)=A\cap B^\ast\subset D,\]</span> 这意味着 <span
class="math inline">\(x_2-x_1\in D\)</span>，即 <span
class="math inline">\(\bar x_1=\bar x_2\)</span>。</p>
<p>然后证明这一映射保持模的加法： <span
class="math display">\[\varphi(a_1+x_1+a_2+x_2)=\overline{x_1+x_2}=\bar
x_1+\bar x_2=\varphi(a_1+x_1)+\varphi(a_2+x_2).\]</span></p>
<p>然后证明这一映射保持环作用： <span
class="math display">\[\varphi(r(a+x))=\varphi(ra+rx)=\overline{rx}=rx+D=r(x+D)=r\varphi(a+x).\]</span></p>
<p>于是 <span class="math inline">\(\varphi\)</span> 确实是环同态。</p>
<p><span class="math inline">\(\varphi\)</span> 显然是满射，然后考虑
<span class="math inline">\(\mathrm{ker}\,\varphi\)</span>。在 <span
class="math inline">\(A+(A^\ast\cap B^\ast)\)</span> 中任取一个 <span
class="math inline">\(a+x\)</span>，其中 <span
class="math inline">\(a\in A\)</span> 以及 <span
class="math inline">\(x\in (A^\ast\cap B^\ast)\)</span>。<span
class="math inline">\(\varphi(a+x)=\bar 0\)</span> 相当于 <span
class="math inline">\(x\in D\)</span>，即 <span
class="math inline">\(x\in (A\cap B^\ast+A^\ast\cap B)\)</span>，因此
<span class="math display">\[a+x\in (A+A\cap B^\ast+A^\ast\cap
B)=A+A^\ast\cap B.\]</span> 于是 <span
class="math inline">\(\mathrm{ker}\,\varphi=A+A^\ast\cap
B\)</span>，这样一来我们就证明了： <span
class="math display">\[\dfrac{A+A^\ast\cap B^\ast}{A+A^\ast\cap B}\simeq
\dfrac{A^\ast\cap B^\ast}{A\cap B^\ast+A^\ast\cap B}.\]</span></p>
<p>注意，“<span class="math inline">\(\simeq\)</span>”右侧关于 <span
class="math inline">\(A,B\)</span> 对称，所以： <span
class="math display">\[\dfrac{B+B^\ast\cap A^\ast}{B+B^\ast\cap A}\simeq
\dfrac{A^\ast\cap B^\ast}{A\cap B^\ast+A^\ast\cap B}.\]</span>
这样就证明了引理。</p>

    </div>
</div>
<p>然后是 Schreier 加细定理。</p>
<div id="Schreier" class="statement theorem plain">
<p><span class="statement-heading"><span class="statement-label">定理
8</span>.</span><span class="statement-spah"> </span><span
class="math inline">\(\,\!\)</span><strong>（Schreier
加细定理）</strong> <span class="math inline">\(R\)</span>-模 <span
class="math inline">\(M\)</span> 的任两个子模序列都有等价的加细。</p>
</div>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        证明
    </div>
    <div class='spoiler-content'>
        <p>考虑 <span class="math inline">\(M\)</span> 的两个序列： <span
class="math display">\[\begin{align*}
&amp;M=M_0\supsetneq M_1\supsetneq M_2\supsetneq\cdots\supsetneq
M_n=\{0\},\\
&amp;M=M&#39;_0\supsetneq M&#39;_1\supsetneq
M&#39;_2\supsetneq\cdots\supsetneq M&#39;_k=\{0\}.
\end{align*}\]</span></p>
<p>现在想办法将第二个序列“加入”第一个序列中。定义 <span
class="math display">\[M_{ij}=M_{i+1}+(M_i\cap M_j&#39;).\]</span>
由于子模的交与和还是子模，所以 <span
class="math inline">\(M_{ij}\)</span> 也是 <span
class="math inline">\(M_i\)</span> 的子模。注意到： <span
class="math display">\[\begin{align*}
M_{i,0}&amp;=M_{i+1}+(M_i\cap M_0&#39;)=M_{i+1}+(M_i\cap M)=M_i,\\
M_{i,k}&amp;=M_{i+1}+(M_i\cap M_k&#39;)=M_{i+1}+(M_i\cap
\{0\})=M_{i+1},\\
M_{i,0}&amp;\supset M_{i,1}\supset M_{i,2}\supset\cdots\supset M_{i,k}
\end{align*}\]</span> 所以 <span class="math inline">\(M_{ij}\)</span>
构成 <span class="math inline">\(\{M_i\}_{i=0}^n\)</span>
的加细。同理，可以构建第二个序列的加细： <span
class="math display">\[M_{ij}&#39;=M_{i+1}&#39;+(M_i&#39;\cap
M_j).\]</span></p>
<p>由于 <span class="math inline">\(M_{i+1}\)</span> 与 <span
class="math inline">\(M_{j+1}&#39;\)</span> 是 <span
class="math inline">\(M_i\)</span> 与 <span
class="math inline">\(M_j&#39;\)</span> 的子模，所以，根据 Zassenhaus
引理有： <span class="math display">\[\dfrac{M_{i+1}+(M_i\cap
M_j&#39;)}{M_{i+1}+(M_i\cap
M_{j+1}&#39;)}\simeq\dfrac{M_{j+1}&#39;+(M_j&#39;\cap
M_i)}{M_{j+1}&#39;+(M_j&#39;\cap M_{i+1})},\]</span> 也就是 <span
class="math display">\[M_{i,j}/M_{i,j+1}\simeq
M&#39;_{j,i}/M&#39;_{j,i+1}.\]</span>
这样一来，得到的两个加细是等价的。</p>

    </div>
</div>
<p>最后是 Jordan-Hölder 定理。</p>
<div id="Jordan-Holder" class="statement theorem plain">
<p><span class="statement-heading"><span class="statement-label">定理
9</span>.</span><span class="statement-spah"> </span><span
class="math inline">\(\,\!\)</span><strong>（Jordan-Hölder
定理）</strong><br />
<span class="math inline">\(R\)</span>-模 <span
class="math inline">\(M\)</span>
的任两个合成序列等价，并且其长度唯一。</p>
</div>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        证明
    </div>
    <div class='spoiler-content'>
        <p>首先证明合成列的加细与自己等价。假设 <span
class="math display">\[M=M_0\supsetneq M_1\supsetneq
M_2\supsetneq\cdots\supsetneq M_n=\{0\}\]</span> 是合成列，即 <span
class="math inline">\(M_i/M_{i+1}\)</span> 是单模。假设 <span
class="math inline">\(M_i\)</span> 与 <span
class="math inline">\(M_{i+1}\)</span> 之间有子模 <span
class="math inline">\(L\)</span>，即 <span
class="math inline">\(M_{i+1}\subset L\subset
M_i\)</span>，那么根据第三同态定理，有 <span
class="math display">\[(M_i/M_{i+1})/(L/M_{i+1})\simeq M/L.\]</span>
但是 <span class="math inline">\(M_i/M_{i+1}\)</span> 是单模，所以 <span
class="math inline">\(L/M_{i+1}\)</span> 只可能为 <span
class="math inline">\(\{0\}\)</span> 或 <span
class="math inline">\(M_i/M_{i+1}\)</span> 自己，这意味着 <span
class="math inline">\(L=M_i\)</span> 或 <span
class="math inline">\(M_{i+1}\)</span>，不会有其他可能。</p>
<p>然后，根据 Schreier
加细定理，任两个合成列存在等价的加细，因此任两个合成列等价。</p>

    </div>
</div>
<p>关于合成列的存在性，有如下定理：</p>
<p><span id="chain-condition-composition-series"></p>
<div id="chain-condition-composition-series"
class="statement theorem plain">
<p><span class="statement-heading"><span class="statement-label">定理
10</span>.</span><span class="statement-spah"> </span><span
class="math inline">\(R\)</span>-模 <span
class="math inline">\(M\)</span> 有一个合成序列当且仅当 <span
class="math inline">\(M\)</span> 同时满足升链条件和降链条件。</p>
</div>
<p></span></p>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        证明
    </div>
    <div class='spoiler-content'>
        <p>“<span class="math inline">\(\Rightarrow\)</span>”：<span
class="math inline">\(\quad\)</span>由于 <span
class="math inline">\(M\)</span> 有长为 <span
class="math inline">\(n\)</span>
的合成列，所以任意一个子模的升降链的长度都不会超过 <span
class="math inline">\(n\)</span>，这自然满足升降链条件。</p>
<p>“<span class="math inline">\(\Leftarrow\)</span>”：<span
class="math inline">\(\quad\)</span>记 <span
class="math inline">\(\mathcal F_0\)</span> 为模 <span
class="math inline">\(M_0=M\)</span>
中除了自己以外的全体子模构成的集合；由于 <span
class="math inline">\(M=M_0\)</span> 满足升链条件，所以 <span
class="math inline">\(\mathcal F_0\)</span> 中有极大元 <span
class="math inline">\(M_1\)</span>。记 <span
class="math inline">\(\mathcal F_1\)</span> 为模 <span
class="math inline">\(M_1\)</span>
中除了自己以外的全体子模构成的集合；<span
class="math inline">\(M_1\)</span> 显然也满足升链条件，所以 <span
class="math inline">\(\mathcal F_1\)</span> 中有极大元 <span
class="math inline">\(M_2\)</span>。将这一过程不断进行下去，就能得到一个子模的降链
<span class="math display">\[M=M_0\supset M_1\supset
M_2\supset\cdots.\]</span> 由于 <span
class="math inline">\(M_0=M\)</span>
又满足降链条件，这一降链必将中止。中止只可能发生在 <span
class="math inline">\(M_n=0\)</span> 处。这样一来就能得到 <span
class="math inline">\(M\)</span>
的一个子模序列。这样得到的序列一定是合成列，否则的话 <span
class="math inline">\(M_{i+1}\)</span> 将不是 <span
class="math inline">\(\mathcal F_i\)</span> 中的极大元。</p>

    </div>
</div>
<h2 id="zorn-引理">Zorn 引理</h2>
<p>在 ZFC 集合论公理中，Zorn 引理是与选择公理等价的命题。以下说明 Zorn
引理的内容以及应用场景。</p>
<div id="partially-ordered-set" class="statement definition plain">
<p><span class="statement-heading"><span class="statement-label">定义
15</span>.</span><span class="statement-spah"> </span><span
class="math inline">\(\,\!\)</span><strong>（偏序集）</strong><br />
(1)<span class="math inline">\(\quad\)</span>如果一个集合 <span
class="math inline">\(X\)</span> 上定义了一个满足以下三个条件的二元关系
<span
class="math inline">\(\preccurlyeq\)</span>，就说这个集合是一个<strong>偏序集（partially
ordered set）</strong>，<span
class="math inline">\(\preccurlyeq\)</span>
称为<strong>偏序关系</strong>：<br />
<span class="math inline">\(\quad\rhd\quad\)</span><span
class="math inline">\(x\preccurlyeq x\)</span>，<br />
<span class="math inline">\(\quad\rhd\quad\)</span>如果 <span
class="math inline">\(x\preccurlyeq y\)</span> 且 <span
class="math inline">\(y\preccurlyeq x\)</span>，那么 <span
class="math inline">\(x=y\)</span>，<br />
<span class="math inline">\(\quad\rhd\quad\)</span>如果 <span
class="math inline">\(x\preccurlyeq y\)</span> 且 <span
class="math inline">\(y\preccurlyeq z\)</span>，那么 <span
class="math inline">\(x\preccurlyeq z\)</span>。<br />
(2)<span class="math inline">\(\quad\)</span>如果一个偏序集 <span
class="math inline">\(X\)</span> 中任两个元素 <span
class="math inline">\(x,y\)</span> 之间要么 <span
class="math inline">\(x\preccurlyeq y\)</span> 要么有 <span
class="math inline">\(y\preccurlyeq
x\)</span>，即不存在无法比较的情况，就说这是一个<strong>全序集</strong>。<br />
(3)<span class="math inline">\(\quad\)</span>在一个偏序集 <span
class="math inline">\(X\)</span> 中，如果有一个元素 <span
class="math inline">\(u\)</span> 满足：<span
class="math inline">\(\forall x\in X\)</span> 都有 <span
class="math inline">\(x\preccurlyeq u\)</span>，就说 <span
class="math inline">\(u\)</span>
是这个偏序集的<strong>上界</strong>。<br />
(4)<span class="math inline">\(\quad\)</span>在一个偏序集 <span
class="math inline">\(X\)</span> 中，如果有一个元素 <span
class="math inline">\(u\)</span> 满足：只要 <span
class="math inline">\(u\preccurlyeq x\)</span> 就有 <span
class="math inline">\(u=x\)</span>，就说 <span
class="math inline">\(u\)</span>
是这个偏序集中的一个<strong>极大元</strong>。</p>
</div>
<p>Zorn 引理是指：</p>
<div id="Zorn"
class="unnumbered statement proposition-unnumbered plain">
<p><span class="statement-heading"><span
class="statement-label">命题</span>.</span><span class="statement-spah">
</span><span class="math inline">\(\,\!\)</span><strong>（Zorn
引理）</strong>
如果一个偏序集中的任意一个全序子集都有上界，那么这个偏序集有极大元。</p>
</div>
<p>Zorn 引理的应用包括：</p>
<div id="linear-space"
class="unnumbered statement theorem-unnumbered plain">
<p><span class="statement-heading"><span
class="statement-label">定理</span>.</span><span class="statement-spah">
</span><span class="math inline">\(\,\!\)</span><br />
(1)<span
class="math inline">\(\quad\)</span>有限维线性空间总有一组基。<br />
(2)<span class="math inline">\(\quad\)</span>假设 <span
class="math inline">\(M\)</span> 是幺环 <span
class="math inline">\(R\)</span> 上的有限生成左模（可以是环 <span
class="math inline">\(R\)</span> 自己），<span
class="math inline">\(N\)</span> 是 <span
class="math inline">\(M\)</span> 的非平凡子模，那么存在一个极大子模
<span class="math inline">\(U\)</span> 使得 <span
class="math inline">\(N\subset U\)</span>，即 <span
class="math inline">\(M\)</span> 的包含了 <span
class="math inline">\(U\)</span> 的子模只有 <span
class="math inline">\(M\)</span> 自己。</p>
</div>
<hr />
<h1 id="整环上的因式分解">整环上的因式分解</h1>
<h2 id="整数环上的贝祖定理">整数环上的贝祖定理</h2>
<p>在小学时，我们经常会遇见 <span class="math display">\[\mathbb
Z_n:=\mathbb Z/n\mathbb
Z=\left\{\bar0,\bar1,\cdots,\overline{n-1}\right\}.\]</span> 可以证明，
<span class="math inline">\(\mathbb Z/n\mathbb Z\)</span>
是一个交换幺环，其加法与乘法为： <span class="math display">\[\bar
a+\bar b=\overline{a+b},\quad \bar a\cdot\bar b=\overline{ab}.\]</span>
<span class="math inline">\(\mathbb Z/n\mathbb Z\)</span> 的零元为 <span
class="math inline">\(\bar0\)</span>，幺元为 <span
class="math inline">\(\bar 1\)</span>。但需要注意的是，仅在 <span
class="math inline">\(n\)</span> 为素数时，<span
class="math inline">\(\mathbb Z/n\mathbb Z\)</span> 才是整环。例如，对于
<span class="math inline">\(\mathbb Z/4\mathbb Z\)</span> 有 <span
class="math inline">\(\bar2\cdot\bar2=\bar0\)</span>，因此 <span
class="math inline">\(\mathbb Z/4\mathbb Z\)</span>
有零因子进而不是整环。</p>
<p>在整数环 <span class="math inline">\(\mathbb Z\)</span>
中，我们将两个整数 <span class="math inline">\(a\)</span> 与 <span
class="math inline">\(b\)</span> 的最大公约数记为 <span
class="math inline">\(\gcd(a,b)\)</span>。关于最大公约数有如下重要定理：</p>
<div id="Bezout" class="statement theorem plain">
<p><span class="statement-heading"><span class="statement-label">定理
11</span>.</span><span class="statement-spah"> </span><span
class="math inline">\(\,\!\)</span><strong>（贝祖定理）</strong> 如果
<span class="math inline">\(d=\gcd(a,b)\)</span>，就必然存在 <span
class="math inline">\(x,y\in\mathbb Z\)</span> 使得 <span
class="math inline">\(xa+yb=d\)</span>。</p>
</div>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        证明
    </div>
    <div class='spoiler-content'>
        <p>首先，不论是“贝祖”还是“裴蜀”，它们都是法国数学家 Bézout
的名字的音译，不是中国人的名字。</p>
<p>贝祖定理可通过<strong>辗转相除法</strong>证明。不妨设 <span
class="math inline">\(a&gt;b&gt;0\)</span>，并令 <span
class="math inline">\(r_1=a\)</span>，<span
class="math inline">\(r_2=b\)</span>。<br />
考虑 <span class="math inline">\(r_1\)</span> 与 <span
class="math inline">\(r_2\)</span> 之间的带余除法 <span
class="math inline">\(r_1=s_3r_2+r_3\)</span>，那么很显然<br />
<span
class="math display">\[d=\gcd(a,b)=\gcd(r_1,r_2)=\gcd(r_2,r_3),\]</span>
再考虑带余除法 <span
class="math inline">\(r_2=s_4r_3+r_4\)</span>，那么<br />
<span class="math display">\[d=\gcd(r_2,r_3)=\gcd(r_3,r_4),\]</span>
如此反复进行下去，直到 <span
class="math inline">\(r_n|r_{n-1}\)</span>，此时<br />
<span class="math display">\[d=r_n.\]</span> 注意到，以上过程中所有的
<span class="math inline">\(r_i\)</span> 都可写为 <span
class="math inline">\(r_{i-1}\)</span> 与 <span
class="math inline">\(r_{i-2}\)</span> 的整系数线性组合，因此 <span
class="math inline">\(d=r_n\)</span> 也可写为 <span
class="math inline">\(r_1=a\)</span> 与 <span
class="math inline">\(r_2=b\)</span> 的整系数线性组合。</p>

    </div>
</div>
<p>贝祖定理的一个推论是：</p>
<div id="Bezout1" class="statement proposition plain">
<p><span class="statement-heading"><span class="statement-label">命题
12</span>.</span><span class="statement-spah"> </span><span
class="math inline">\(\,\!\)</span> 如果 <span
class="math inline">\(a,b&gt;0\)</span> 且 <span
class="math inline">\(\gcd(a,b)=1\)</span>，那么只有有限个正整数不能表达为
<span class="math inline">\(a\)</span> 与 <span
class="math inline">\(b\)</span> 的正整数系数线性组合。</p>
</div>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        证明
    </div>
    <div class='spoiler-content'>
        <p>首先，根据贝祖定理，我们总可以找到 <span
class="math inline">\(x\)</span> 与 <span
class="math inline">\(y\)</span> 使得 <span
class="math inline">\(xa-yb=1\)</span>。此处我们假设 <span
class="math inline">\(b\)</span> 前面的系数是负的。<br />
那么对任意一个正整数 <span class="math inline">\(k\)</span>，考虑它对
<span class="math inline">\(b\)</span> 的带余除法 <span
class="math inline">\(k=sb+r\)</span>，其中 <span
class="math inline">\(0\leqslant r&lt;b\)</span>。<br />
此时就有：<br />
<span class="math display">\[k=sb+r(xa-yb)=rxa+(s-ry)b.\]</span> 由于
<span class="math inline">\(y\)</span> 是固定的，<span
class="math inline">\(r&lt;b\)</span> ，因此最多只有 <span
class="math inline">\(by\)</span> 个正整数无法表示为 <span
class="math inline">\(a\)</span> 与 <span
class="math inline">\(b\)</span> 的正整数系数线性组合。</p>

    </div>
</div>
<p>贝祖定理的另一个推论是：</p>
<div id="Bezout2" class="statement proposition plain">
<p><span class="statement-heading"><span class="statement-label">命题
13</span>.</span><span class="statement-spah"> </span><span
class="math inline">\(\,\!\)</span> 只有当 <span
class="math inline">\(\mathrm{gcd}(a,n)=1\)</span> 时，<span
class="math inline">\(\mathbb Z/n\mathbb Z\)</span> 中的元素 <span
class="math inline">\(\bar a\)</span> 才有乘法逆元。</p>
</div>
<p>这是因为： <span class="math display">\[xa+yn=1\quad \Rightarrow\quad
\bar x\cdot \bar a=\bar 1.\]</span> 我们将 <span
class="math inline">\(\mathbb Z/n\mathbb Z\)</span>
中有乘法逆元的元素组成的集合记为 <span class="math inline">\(\mathbb
Z_n^\times\)</span>，它们在乘法下能构成群。群 <span
class="math inline">\(\mathbb Z_n^\times\)</span> 的阶数记为 <span
class="math inline">\(\varphi(n)\)</span>，即<strong>欧拉 <span
class="math inline">\(\varphi\)</span>-函数</strong>。可以证明，如果
<span class="math inline">\(n=p_1^{e_1}p_2^{e_2}\cdots
p_k^{e_k}\)</span> 是 <span class="math inline">\(n\)</span>
的质因子分解，那么： <span
class="math display">\[\varphi(n)=n\prod_{i=1}^k(1-1/p_i).\]</span>
特别地，如果 <span class="math inline">\(p\)</span> 是素数那么 <span
class="math inline">\(\varphi(p)=p-1\)</span>。</p>
<p>由于有限群中，任意群元的阶总是整除群阶，所以：</p>
<div id="Euler-Fermat" class="statement theorem plain">
<p><span class="statement-heading"><span class="statement-label">定理
14</span>.</span><span class="statement-spah"> </span><span
class="math inline">\(\,\!\)</span><strong>（欧拉-费马定理）</strong>
如果 <span class="math inline">\(\gcd(a,n)=1\)</span> 就必然有 <span
class="math inline">\(a^{\varphi(n)}\equiv 1\;\mathrm{mod}\;
n\)</span>。</p>
</div>
<p>欧拉-费马定理的一个重要推论是：</p>
<div id="Euler-Fermat2" class="statement proposition plain">
<p><span class="statement-heading"><span class="statement-label">命题
15</span>.</span><span class="statement-spah"> </span><span
class="math inline">\(\,\!\)</span> 如果 <span
class="math inline">\(p\)</span> 是奇素数，就有 <span
class="math inline">\(2^{p-1}\equiv 1\;\mathrm{mod}\; p\)</span>。</p>
</div>
<p>人们发现，只有少量合数（<span
class="math inline">\(n&lt;10000\)</span> 时只有 <span
class="math inline">\(22\)</span>
个）也满足这一关系，因此这一关系式可用于大致判断一个数是否为素数。实际上，只有少量的合数（称为
Carmichael 数）<span class="math inline">\(n\)</span> 满足 “<span
class="math inline">\(\;\forall a\in \mathbb Z_n^\times\;\)</span> 都有
<span class="math inline">\(\;a^{n-1}\equiv 1\;\mathrm{mod}\;
n\;\)</span>” 这一条件，这也可用于大致判断一个数是否为素数。</p>
<p>最后，贝祖定理可用于解同余方程或同余方程组。例如：</p>
<div id="mod-equation" class="statement proposition plain">
<p><span class="statement-heading"><span class="statement-label">命题
16</span>.</span><span class="statement-spah"> </span><span
class="math inline">\(\,\!\)</span><strong>（中国剩余定理的应用）</strong><br />
假设 <span class="math inline">\(n_i(i=1\sim k)\)</span> 互素，<span
class="math inline">\(n=n_1n_2\cdots n_k\)</span>，那么方程组<br />
<span class="math display">\[x\equiv a_i\;\mathrm{mod}\;n_i\]</span> 在
<span class="math inline">\(\mathrm{mod}\;n\)</span>
的意义下有唯一解，其求解流程为：<br />
<span class="math display">\[\begin{align*}
u_in_i+v_i(n/n_i)=1\quad\Rightarrow\quad v_i(n/n_i)\equiv
1\;\mathrm{mod}\;n_i\quad\Rightarrow\quad x=\sum_{i}a_i\cdot v_i(n/n_i).
\end{align*}\]</span></p>
</div>
<h2 id="唯一分解整环">唯一分解整环</h2>
<p>现在，我们来讨论整环，即不以 <span class="math inline">\(0\)</span>
为乘数的乘法不会给出 <span class="math inline">\(0\)</span>
为结果的交换幺环。<br />
整数环 <span class="math inline">\(\mathbb Z\)</span> 以及域 <span
class="math inline">\(F\)</span> 上的多项式环 <span
class="math inline">\(F[x]\)</span>
都是整环。除了这两个例子之外，另一类重要的例子是：</p>
<div id="Z-sqrt-n" class="statement example definition unnumbered">
<p><span class="statement-heading"><span
class="statement-label">例子</span>：</span><span
class="statement-spah"> </span><span class="math inline">\(\,\!\)</span>
假设 <span class="math inline">\(n\)</span> 是整数，那么 <span
class="math display">\[\begin{equation*}
\mathbb Z[\sqrt{n}]:=\left\lbrace a+b\sqrt{n}:\quad a,b\in\mathbb
Z\right\rbrace  
\end{equation*}\]</span> 在 <span class="math inline">\(n&lt;0\)</span>
或 <span class="math inline">\(n&gt;0\)</span> 但 <span
class="math inline">\(n\)</span> 不是正整数的平方时是整环，且 <span
class="math inline">\(\mathbb Z[\sqrt{n}]\neq\mathbb Z\)</span>。</p>
</div>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        证明
    </div>
    <div class='spoiler-content'>
        <p>我们考虑 <span
class="math inline">\((a+b\sqrt{x})(c+d\sqrt{x})=0\)</span>
在何时成立。<br />
显然，如果 <span class="math inline">\(d=0\)</span>，那 <span
class="math inline">\(c\)</span> 取 <span
class="math inline">\(0\)</span> 才能使得 <span
class="math inline">\((a+b\sqrt{x})(c+d\sqrt{x})=0\)</span>
成立。于是我们只考虑 <span class="math inline">\(d\neq 0\)</span>
的情形。同理，我们也只需要考虑 <span class="math inline">\(c\neq
0\)</span> 的情形。<br />
在 <span class="math inline">\(ad+bc=0\)</span> 以及 <span
class="math inline">\(ac+bdx=0\)</span> 中消去 <span
class="math inline">\(d\)</span> 就发现 <span
class="math inline">\(ac=b^2cx/a\)</span>，如果 <span
class="math inline">\(c\neq 0\)</span> 就有 <span
class="math inline">\(a^2=b^2x\)</span>，这只在 <span
class="math inline">\(a=b=0\)</span> 时才可能成立。</p>

    </div>
</div>
<p>整环具有一些与整数类似的性质，如在一些整环上可以像在整数中一样做因式分解。但有些整环又不能做因式分解——如
<span class="math inline">\(\mathbb
Z[\sqrt{-5}]\)</span>。接下来，我们就来讨论整除、最大公因子等概念在一般整环中的推广，完成这些准备工作之后，我们就可以讨论哪些整环可以像在整数环
<span class="math inline">\(\mathbb Z\)</span> 中一样做因式分解了。</p>
<div id="division" class="statement definition plain">
<p><span class="statement-heading"><span class="statement-label">定义
16</span>.</span><span class="statement-spah"> </span><span
class="math inline">\(\,\!\)</span><strong>（整除）</strong><br />
(1)<span class="math inline">\(\quad\)</span>在整环上，如果能找到一个
<span class="math inline">\(b\)</span> 使得 <span
class="math inline">\(x=ab\)</span>，就说 <span
class="math inline">\(a\)</span> <strong>整除</strong> <span
class="math inline">\(x\)</span>，记为 <span
class="math inline">\(a|x\)</span>。<br />
(2)<span class="math inline">\(\quad\)</span>如果 <span
class="math inline">\(x|y\)</span> 且 <span
class="math inline">\(y|x\)</span>，就说 <span
class="math inline">\(x\)</span> 与 <span
class="math inline">\(y\)</span> <strong>等价</strong>，记为 <span
class="math inline">\(x\sim y\)</span>。</p>
</div>
<p>不难证明，如果 <span class="math inline">\(x\sim y\)</span>，就一定有
<span class="math inline">\(x=uy\)</span>，其中 <span
class="math inline">\(u\)</span> 是整环中的乘法可逆元。<br />
对于整数环 <span class="math inline">\(\mathbb
Z\)</span>，乘法可逆元只有 <span
class="math inline">\(\pm1\)</span>；对于域 <span
class="math inline">\(F\)</span> 上的多项式环 <span
class="math inline">\(F[x]\)</span>，乘法可逆元就是 <span
class="math inline">\(F\)</span>
中的非零元素。整环中的乘法可逆元起到了类似于 <span
class="math inline">\(\mathbb Z\)</span> 中 <span
class="math inline">\(1\)</span> 的作用。</p>
<div id="gcd" class="statement definition plain">
<p><span class="statement-heading"><span class="statement-label">定义
17</span>.</span><span class="statement-spah"> </span><span
class="math inline">\(\,\!\)</span><strong>（公因子）</strong><br />
(1)<span class="math inline">\(\quad\)</span>如果 <span
class="math inline">\(x|a\)</span> 且 <span
class="math inline">\(x|b\)</span>，就说 <span
class="math inline">\(x\)</span> 是 <span
class="math inline">\(a\)</span> 与 <span
class="math inline">\(b\)</span> 的<strong>公因子</strong>。<br />
(2)<span class="math inline">\(\quad\)</span>如果 <span
class="math inline">\(d\)</span> 是 <span
class="math inline">\(a\)</span> 与 <span
class="math inline">\(b\)</span> 的公因子，且对任意一个 <span
class="math inline">\(a\)</span> 与 <span
class="math inline">\(b\)</span> 的公因子 <span
class="math inline">\(d_1\)</span> 来说都有 <span
class="math inline">\(d_1|d\)</span>，就说 <span
class="math inline">\(d\)</span> 是 <span
class="math inline">\(a\)</span> 与 <span
class="math inline">\(b\)</span> 的<strong>最大公因子</strong>。<br />
(3)<span class="math inline">\(\quad\)</span>果 <span
class="math inline">\(a\)</span> 与 <span
class="math inline">\(b\)</span> 的公因子只有乘法可逆元，就说 <span
class="math inline">\(ab\)</span> <strong>互素</strong>。</p>
</div>
<p>一般而言，两个元素之间的最大公因子不一定存在，但只要 <span
class="math inline">\(a\)</span> 与 <span
class="math inline">\(b\)</span>
的最大公因子存在，那么它在等价的意义下是唯一的，记为 <span
class="math inline">\(\gcd(a,b)\)</span>。下面给出最大公因子不存在的例子：</p>
<div id="no-gcd" class="statement example definition unnumbered">
<p><span class="statement-heading"><span
class="statement-label">例子</span>：</span><span
class="statement-spah"> </span><span class="math inline">\(\,\!\)</span>
<span class="math inline">\(\mathbb Z[\sqrt{-5}]\)</span> 中，<span
class="math inline">\(6\)</span> 与 <span
class="math inline">\(2(1+\sqrt{-5})\)</span> 有公因子 <span
class="math inline">\(2\)</span> 和 <span
class="math inline">\((1+\sqrt{-5})\)</span>，但却没有最大公因子，因为<br />
<span
class="math display">\[6/[2(1+\sqrt{-5})]=(1-\sqrt{-5})/2\notin\mathbb
Z[\sqrt{-5}]\]</span></p>
</div>
<p>讨论整环上的整除问题时，需要考虑两类特殊的元素：</p>
<div id="irreducible" class="statement definition plain">
<p><span class="statement-heading"><span class="statement-label">定义
18</span>.</span><span class="statement-spah"> </span><span
class="math inline">\(\,\!\)</span><strong>（素元与不可约元）</strong><br />
(1)<span class="math inline">\(\quad\)</span>如果整环上的元素 <span
class="math inline">\(p\)</span> 满足：如果 <span
class="math inline">\(p|(ab)\)</span> 则要么 <span
class="math inline">\(p|a\)</span> 要么 <span
class="math inline">\(p|b\)</span>，就称 <span
class="math inline">\(p\)</span> 为<strong>素元</strong>。<br />
(2)<span class="math inline">\(\quad\)</span>如果整环上的元素 <span
class="math inline">\(p\)</span> 满足：如果 <span
class="math inline">\(p=ab\)</span> 则 <span
class="math inline">\(a,b\)</span> 中至少一个为乘法可逆元，就说 <span
class="math inline">\(p\)</span> 是<strong>不可约</strong>的。</p>
</div>
<p>对于整数环 <span class="math inline">\(\mathbb
Z\)</span>，不可约元也都是素元，它们就是我们常说的素数。<br />
可以证明：</p>
<div id="prime-irreducible" class="statement theorem plain">
<p><span class="statement-heading"><span class="statement-label">定理
17</span>.</span><span class="statement-spah"> </span><span
class="math inline">\(\,\!\)</span> 整环中的素元一定是不可约元。</p>
</div>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        证明
    </div>
    <div class='spoiler-content'>
        <p>假设 <span class="math inline">\(p\)</span> 是素元且 <span
class="math inline">\(p=ab\)</span>。 根据素元的定义，可以假定 <span
class="math inline">\(p|a\)</span>。因此存在 <span
class="math inline">\(c\)</span> 使得 <span
class="math inline">\(a=pc\)</span>。这样一来就有 <span
class="math inline">\(p=bcp\)</span>，这意味着 <span
class="math inline">\(bc=1\)</span>，即 <span
class="math inline">\(b\)</span> 是乘法可逆元。</p>

    </div>
</div>
<p>但不可约元不一定是素元：</p>
<div id="irreducible-not-prime"
class="statement example definition unnumbered">
<p><span class="statement-heading"><span
class="statement-label">例子</span>：</span><span
class="statement-spah"> </span><span class="math inline">\(\,\!\)</span>
<span class="math inline">\(\mathbb Z[\sqrt{-5}]\)</span> 中，<span
class="math inline">\(3\)</span> 与 <span
class="math inline">\((2\pm\sqrt{-5})\)</span> 都是不可约元，<span
class="math inline">\(3|9=(2+\sqrt{-5})(2-\sqrt{-5})\)</span>，但 <span
class="math inline">\(3\)</span> 并不整除 <span
class="math inline">\((2\pm\sqrt{-5})\)</span> 中的任意一个。</p>
</div>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        证明
    </div>
    <div class='spoiler-content'>
        <p>我们来证明 <span class="math inline">\(2\)</span>、<span
class="math inline">\(3\)</span> 与 <span
class="math inline">\((2\pm\sqrt{-5})\)</span> 都是不可约元。<br />
我们在 <span class="math inline">\(\mathbb
Z[\sqrt{-5}]\)</span>上可以定义范数 <span
class="math inline">\(N(a+b\sqrt{-5}):=a^2+5b^2\)</span>。由于 <span
class="math inline">\(\mathbb Z[\sqrt{-5}]\subset\mathbb
C\)</span>，所以范数自然也满足：<br />
<span
class="math display">\[N[(a+b\sqrt{-5})(c+d\sqrt{-5})]=N(a+b\sqrt{-5})N(c+d\sqrt{-5})\]</span>
不难看出，范数不可能取 <span class="math inline">\(2\)</span> 或 <span
class="math inline">\(3\)</span>。考虑到 <span
class="math inline">\(N(2)=4\)</span>、<span
class="math inline">\(N(3)=9\)</span> 以及 <span
class="math inline">\(N(2\pm\sqrt{5})=9\)</span>，由于范数不可能取 <span
class="math inline">\(2\)</span> 和 <span
class="math inline">\(3\)</span>，而 <span
class="math inline">\(2\)</span> 和 <span
class="math inline">\(3\)</span> 是 <span
class="math inline">\(4\)</span> 和 <span
class="math inline">\(9\)</span> 仅有的因子，因此 <span
class="math inline">\(2\)</span>、<span
class="math inline">\(3\)</span>、<span
class="math inline">\(2\pm\sqrt{-5}\)</span>
都不可能拆成两个其他的数的乘积，因此它们都不可约。</p>

    </div>
</div>
<p>我们称“不可约元都是素元”这一条件为<strong>素性条件</strong>。我们可以证明：</p>
<p><span id="Bezout-to-prime"></p>
<div id="irreducible-is-prime" class="statement proposition plain">
<p><span class="statement-heading"><span class="statement-label">命题
18</span>.</span><span class="statement-spah"> </span><span
class="math inline">\(\,\!\)</span> 在一个整环中，如果对任意两个互素的
<span class="math inline">\(a,b\)</span> 都存在一组 <span
class="math inline">\(u,v\)</span> 使得 <span
class="math inline">\(ua+vb=1\)</span>，那么这个整环中的不可约元一定是素元。</p>
</div>
<p></span></p>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        跳转至...
    </div>
    <div class='spoiler-content'>
        <p><font color=grey>[<a href="#thm_PID-is-UFD">PID 一定为
UFD</a>]</font></p>

    </div>
</div>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        证明
    </div>
    <div class='spoiler-content'>
        <p>假设 <span class="math inline">\(p\)</span> 不可约且 <span
class="math inline">\(p|(ab)\)</span>。由于 <span
class="math inline">\(p\)</span> 不可约，所以 <span
class="math inline">\(\gcd(p,b)\)</span> 只有 <span
class="math inline">\(p\)</span> 与可逆元两种情形。<br />
如果 <span class="math inline">\(\gcd(p,b)=p\)</span>，那么 <span
class="math inline">\(p|b\)</span>。 如果 <span
class="math inline">\(\gcd(p,b)\)</span> 是可逆元，那么 <span
class="math inline">\(p\)</span> 与 <span
class="math inline">\(b\)</span> 互素，此时存在 <span
class="math inline">\(u,v\)</span> 使得 <span
class="math inline">\(ub+vp=1\)</span>，考虑到 <span
class="math inline">\(a=a1=uba+vpa\)</span>，就有 <span
class="math inline">\(p|a\)</span>。</p>

    </div>
</div>
<p>完成以上准备工作后，我们可以讨论整环上的因子分解了。</p>
<div id="UFD" class="statement definition plain">
<p><span class="statement-heading"><span class="statement-label">定义
19</span>.</span><span class="statement-spah"> </span><span
class="math inline">\(\,\!\)</span><strong>（唯一分解整环）</strong><br />
如果一个整环中的任意一个元素 <span class="math inline">\(x\)</span>
都可以拆分为有限个不可约元 <span class="math inline">\(p_i\)</span>
的乘积 （这个条件称为<strong>因子链条件</strong>）： <span
class="math display">\[\begin{align*}
x=p_1p_2\cdots p_n,
\end{align*}\]</span>
并且如果存在两种这样的因子分解，那么这两种因子分解给出的不可逆元在恰当地排列顺序之后总是互相等价的——即如果
<span class="math inline">\(x=p_1\cdots p_n=q_1\cdots q_m\)</span>
就必然有 <span class="math inline">\(m=n\)</span> 且存在一个 <span
class="math inline">\(1\sim n\)</span> 的排列使得 <span
class="math inline">\(p_i\sim
q_{\sigma(i)}\)</span>——就说个整环是<strong>唯一因子分解整环（UFD）</strong>。</p>
</div>
<p>不是 UFD 的例子就是反复提到的：</p>
<div id="not-UFD" class="statement example definition unnumbered">
<p><span class="statement-heading"><span
class="statement-label">例子</span>：</span><span
class="statement-spah"> </span><span class="math inline">\(\,\!\)</span>
<span class="math inline">\(\mathbb Z[\sqrt{-5}]\)</span> 不是 UFD，因为
<span class="math inline">\(9\)</span> 存在两种不等价的因子分解：<span
class="math display">\[9=3^2=(2+\sqrt{-5})(2-\sqrt{-5})\]</span></p>
</div>
<p>不难想象：</p>
<div id="divider-in-UFD" class="statement theorem plain">
<p><span class="statement-heading"><span class="statement-label">定理
19</span>.</span><span class="statement-spah"> </span><span
class="math inline">\(\,\!\)</span> 如果一个整环 <span
class="math inline">\(R\)</span> 是 UFD，那么：<br />
(1)<span class="math inline">\(\quad\)</span>如果 <span
class="math inline">\(a\in R\)</span> 且 <span
class="math inline">\(a=p_1p_2\cdots p_n\)</span>，那么 <span
class="math inline">\(a\)</span> 不可能有不等价于某个 <span
class="math inline">\(p_i\)</span> 的因子。<br />
(2)<span class="math inline">\(\quad R\)</span>
中任两个元素都有最大公因子。</p>
</div>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        证明
    </div>
    <div class='spoiler-content'>
        <p>对于 (1)，如果 <span class="math inline">\(a\)</span> 还有 <span
class="math inline">\(p_1\sim p_n\)</span> 以外的因子 <span
class="math inline">\(q\)</span>：<span
class="math inline">\(a=qc\)</span>，那么对 <span
class="math inline">\(c\)</span> 做因子分解：<span
class="math inline">\(c=q_1&#39;q_2&#39;\cdots
q_s&#39;\)</span>，就能得到 <span class="math inline">\(a\)</span>
的另一种因子分解 <span class="math inline">\(a=qq_1&#39;q_2&#39;\cdots
q_s&#39;\)</span>，这与 UFD 的定义矛盾。</p>
<p>对于 (2)，从 UFD 中任取两个元素 <span
class="math inline">\(a,b\)</span>，考虑它们的因子分解，并将公共因子排在前面：
<span class="math inline">\(a=p_1^{a_1}\cdots p_k^{a_k}x_1^{s_1}\cdots
x_m^{s_m}\)</span>， <span class="math inline">\(b=p_1^{b_1}\cdots
p_k^{b_k}y_1^{r_1}\cdots y_n^{r_n}\)</span>，那么： <span
class="math display">\[\gcd(a,b)=p_1^{\min(a_1,b_1)}\cdots
p_k^{\min(a_k,b_k)}.\]</span></p>

    </div>
</div>
<p>对于 UFD，我们发现：</p>
<div id="which-is-UFD" class="statement theorem plain">
<p><span class="statement-heading"><span class="statement-label">定理
20</span>.</span><span class="statement-spah"> </span><span
class="math inline">\(\;\)</span>一个整环是 UFD <span
class="math inline">\(\;\Leftrightarrow\;\)</span>
这个整环满足因子链条件，且所有的不可约元都是素元。</p>
</div>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        证明
    </div>
    <div class='spoiler-content'>
        <p>对于 <span class="math inline">\(\Rightarrow\)</span>，只需要证明 UFD
中的不可约元都是素元。假设 <span class="math inline">\(p\)</span>
不可约， <span class="math inline">\(p|ab\)</span>，并且 <span
class="math inline">\(p\)</span> 不整除 <span
class="math inline">\(a\)</span>。不难看出此时的 <span
class="math inline">\(\gcd(a,p)\)</span> 一定是可逆元。 由于，<span
class="math inline">\(p|ab\)</span> 并且 <span
class="math inline">\(p|bp\)</span>，所以 <span
class="math inline">\(p|\gcd(ab,pb)\)</span>，但 <span
class="math inline">\(\gcd(ab,pb)=b\gcd(a,p)\sim b\)</span>，因此 <span
class="math inline">\(p|b\)</span>。</p>
<p>对于 <span
class="math inline">\(\Leftarrow\)</span>，可用数学归纳法证明，其大致思路如下。考虑
<span class="math inline">\(x\)</span> 的任意两种因子分解：<span
class="math inline">\(x=p_1p_2\cdots p_n=q_1q_2\cdots
q_m\)</span>。因为我们假定了不可约元都是素元，所以这里的 <span
class="math inline">\(p_i,q_j\)</span> 也都是素元。由于 <span
class="math inline">\(p_n\)</span> 是素元，<span
class="math inline">\(p_n|(q_1q_2\cdots q_m)\)</span>，所以必然存在一个
<span class="math inline">\(q_j\)</span> 使得 <span
class="math inline">\(p_n|q_j\)</span>，不妨调整 <span
class="math inline">\(q_j\)</span> 之间的顺序使它就是 <span
class="math inline">\(q_m\)</span>。由于 <span
class="math inline">\(p_n\)</span> 与 <span
class="math inline">\(q_m\)</span> 都不可约，所以必然有 <span
class="math inline">\(p_n\sim q_m\)</span>。这样一来我们就发现 <span
class="math inline">\(p_1p_2\cdots p_{n-1}\sim q_1q_2\cdots
q_{m-1}\)</span>。由于 <span class="math inline">\(n\)</span> 与 <span
class="math inline">\(m\)</span>
都是有限的（因子链条件），这样的步骤可一直进行下去，最终我们发现 <span
class="math inline">\(m=n\)</span> 且 <span
class="math inline">\(p_i\sim q_i\)</span>。</p>

    </div>
</div>
<h2 id="主理想整环与欧几里得环">主理想整环与欧几里得环</h2>
<div id="PID" class="statement definition plain">
<p><span class="statement-heading"><span class="statement-label">定义
20</span>.</span><span class="statement-spah"> </span><span
class="math inline">\(\,\!\)</span><strong>（主理想整环）</strong><br />
如果一个整环 <span class="math inline">\(R\)</span> 是主理想环，即 <span
class="math inline">\(R\)</span> 中所有的理想都具有 <span
class="math inline">\(Ra\)</span> （其中 <span
class="math inline">\(a\in R\)</span>）
的形式，就说这是一个<strong>主理想整环（PID）</strong>。</p>
</div>
<p>可以证明：</p>
<p><span id='PID-1'></p>
<div id="PID1" class="statement theorem plain">
<p><span class="statement-heading"><span class="statement-label">定理
21</span>.</span><span class="statement-spah"> </span><span
class="math inline">\(\,\!\)</span> 如果环 <span
class="math inline">\(R\)</span> 是 PID，<span
class="math inline">\(a,b\in R\)</span>，那么 <span
class="math inline">\(\gcd(a,b)\)</span> 存在，且存在 <span
class="math inline">\(u,v\in R\)</span> 使得 <span
class="math inline">\(ua+vb=\gcd(a,b)\)</span>。</p>
</div>
<p></span></p>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        证明
    </div>
    <div class='spoiler-content'>
        <p>不难想象， <span class="math inline">\(Ra+Rb\)</span> 也是 <span
class="math inline">\(R\)</span> 的理想，因此是主理想，假设它由 <span
class="math inline">\(d\)</span> 生成，那么就存在 <span
class="math inline">\(u,v\in R\)</span> 使得 <span
class="math inline">\(ua+vb=d\)</span>。</p>
<p>现在我们证明 <span
class="math inline">\(d=\gcd(a,b)\)</span>。首先，<span
class="math inline">\(a,b\in(d)\)</span>，所以 <span
class="math inline">\(d|a\)</span> 且 <span
class="math inline">\(d|b\)</span>，因此 <span
class="math inline">\(d\)</span> 是公因子。其次，任取 <span
class="math inline">\(a,b\)</span> 的一个公因子 <span
class="math inline">\(d_1\)</span>，由于 <span
class="math inline">\(d_1|a\)</span> 且 <span
class="math inline">\(d_1|b\)</span>，所以 <span
class="math inline">\(d_1|(ua+vb)\)</span>，因此 <span
class="math inline">\(d_1|d\)</span>。所以 <span
class="math inline">\(d=\gcd(a,b)\)</span>。</p>

    </div>
</div>
<p>因此我们可以证明：</p>
<p><span id='thm_PID-is-UFD'></p>
<div id="PID-is-UFD" class="statement theorem plain">
<p><span class="statement-heading"><span class="statement-label">定理
22</span>.</span><span class="statement-spah"> </span><span
class="math inline">\(\,\!\)</span> 如果环 <span
class="math inline">\(R\)</span> 是 PID，那么它一定是 UFD。</p>
</div>
<p></span></p>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        证明
    </div>
    <div class='spoiler-content'>
        <p>只需证明 PID 满足素性条件与因子链条件即可。</p>
<p>对于素性条件，我们刚刚证明了 <a href="#PID-1">PID
满足贝祖定理</a>，之前我们又证明了 <a
href="#Bezout-to-prime">如果一个整环满足贝祖定理那么所有的不可约元一定是素元</a>，因此
PID 满足素性条件。</p>
<p>对于因子链条件，用反证法证明。从 PID 中任取一个元素 <span
class="math inline">\(a\)</span>，假设 <span
class="math inline">\(a\)</span> 不能分解为有限个不可约元的乘积，那么
<span class="math inline">\(a\)</span> 本身一定不是不可约元（否则 <span
class="math inline">\(a\)</span> 就是 <span
class="math inline">\(1\)</span> 个不可约元的乘积）。<br />
假设 <span class="math inline">\(a=a_1b\)</span>，且其中 <span
class="math inline">\(b\)</span> 不可逆， <span
class="math inline">\(a_1\)</span>
也不能分解为有限个不可约元的乘积。这样一来，<span
class="math inline">\(a\in(a_1)\)</span>，且 <span
class="math inline">\((a)\subsetneq(a_1)\)</span>。对 <span
class="math inline">\(a_1\)</span>
也进行这样的操作，就能得到一个理想的升链： <span
class="math display">\[(a)\subsetneq(a_1)\subsetneq(a_2)\subsetneq\cdots\]</span>
考虑 <span class="math inline">\(\cup_{i=1}^\infty(a_i)\)</span>，它也是
PID 的理想，因此也是主理想，假设 <span
class="math inline">\(\cup_{i=1}^\infty(a_i)=(d)\)</span>。<br />
由于 <span class="math inline">\(d\in
\cup_{i=1}^\infty(a_i)\)</span>，因此存在某个 <span
class="math inline">\(k\)</span> 使得 <span class="math inline">\(d\in
(a_k)\)</span>。这样一来，<span class="math inline">\((d)\subset
(a_k)\subsetneq(a_{k+1})\subset(d)\)</span>。出现了矛盾。<br />
从这一证明可以看出，主理想整环是诺特环。</p>

    </div>
</div>
<p>比主理想整环更严格的概念是欧几里得环：</p>
<div id="Euclidean-domain" class="statement definition plain">
<p><span class="statement-heading"><span class="statement-label">定义
21</span>.</span><span class="statement-spah"> </span><span
class="math inline">\(\,\!\)</span><strong>（欧几里得环）</strong><br />
如果 <span class="math inline">\(R\)</span> 是整环，且存在一个 从 <span
class="math inline">\(R\)</span> 到 <span class="math inline">\(\mathbb
N\)</span> 的映射 <span
class="math inline">\(d\)</span>，使它们满足：对任意的 <span
class="math inline">\(a,b\in R\)</span>，都存在 <span
class="math inline">\(r,q\in R\)</span> 使得：</p>
<center>
<p><span class="math inline">\(a=qb+r,\quad r=0\;\)</span>或<span
class="math inline">\(\;d(r)&lt;d(b)\)</span>,</p>
</center>
<p>就说 <span class="math inline">\(R\)</span> 是一个欧几里得整环。</p>
</div>
<p>欧几里得环大致可理解为能做带余除法的环。整数环与数域上的多项式环都是欧几里得环。可以证明：</p>
<div id="EuclidRing-is-PID" class="statement theorem plain">
<p><span class="statement-heading"><span class="statement-label">定理
23</span>.</span><span class="statement-spah"> </span><span
class="math inline">\(\,\!\)</span> 欧几里得环一定是 PID。</p>
</div>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        证明
    </div>
    <div class='spoiler-content'>
        <p>假设 <span class="math inline">\(R\)</span> 是欧几里得环，<span
class="math inline">\(I\)</span> 是 <span
class="math inline">\(R\)</span> 的理想。假设 <span
class="math inline">\(b\in I\)</span> 使得 <span
class="math inline">\(d(b)\)</span> 是 <span
class="math inline">\(d(I)\)</span> 中最小的。然后在 <span
class="math inline">\(I\)</span> 中任取一个元素 <span
class="math inline">\(a\)</span>，并考虑带余除法 <span
class="math inline">\(a=qb+r\)</span>。由于 <span
class="math inline">\(d(b)\)</span> 是 <span
class="math inline">\(d(I)\)</span> 中最小的，所以 <span
class="math inline">\(r\)</span> 只可能为 <span
class="math inline">\(0\)</span>，因此 <span
class="math inline">\(a=qb\)</span>，这意味着 <span
class="math inline">\(I\)</span> 是 <span
class="math inline">\(b\)</span> 生成的主理想。</p>

    </div>
</div>
<hr />
<h1 id="主理想整环上的有限生成模">主理想整环上的有限生成模</h1>
<p>本节只考虑<strong>有限生成模</strong>：如果 <span
class="math inline">\(M\)</span> 是有限生成的左 <span
class="math inline">\(R\)</span>-模，那么存在 <span
class="math inline">\(u_1,u_2,\cdots,u_n\in M\)</span>，使得 <span
class="math inline">\(M=Rx_1+Rx_2+\cdots+Rx_n\)</span>。</p>
<h2 id="扭模无扭模与自由模">扭模、无扭模与自由模</h2>
<div id="tension-module" class="statement definition plain">
<p><span class="statement-heading"><span class="statement-label">定义
22</span>.</span><span class="statement-spah"> </span><span
class="math inline">\(\,\!\)</span><strong>（零化子与扭模）</strong><br />
假设 <span class="math inline">\(R\)</span> 是一个幺环，<span
class="math inline">\(M\)</span> 是一个左 <span
class="math inline">\(R\)</span>-模，<span
class="math inline">\(m\in\mathbb M\)</span>，那么：<br />
(1)<span class="math inline">\(\quad\)</span>集合 <span
class="math display">\[\mathrm{ann}(m):=\left\lbrace rm=0:\;\; r\in
R\right\rbrace\]</span> 称为 <span class="math inline">\(m\)</span>
的<strong>零化子</strong>，显然 <span
class="math inline">\(\mathrm{ann}(m)\)</span> 构成幺环 <span
class="math inline">\(R\)</span> 的一个左理想。<br />
(2)<span class="math inline">\(\quad\)</span>假设 <span
class="math inline">\(N\)</span> 是 <span
class="math inline">\(M\)</span> 的子集，那么 <span
class="math inline">\(\mathrm{ann}(N):=\bigcap_{x\in
N}\mathrm{ann}(x)\)</span>。可以证明，<span
class="math inline">\(N\)</span> 是子模时 <span
class="math inline">\(\mathrm{ann}(N)\)</span> 构成双边理想。<br />
(3)<span class="math inline">\(\quad\)</span>如果 <span
class="math inline">\(\mathrm{ann}(m)\)</span> 有 <span
class="math inline">\(0\)</span> 以外的元素就说 <span
class="math inline">\(m\)</span> 是 <span
class="math inline">\(M\)</span> 中的一个<strong>扭元（torsion
element）</strong>，否则就说 <span class="math inline">\(m\)</span> 是
<span class="math inline">\(M\)</span>
的一个<strong>自由元</strong>。<br />
(4)<span class="math inline">\(\quad\)</span>左 <span
class="math inline">\(R\)</span>-模 <span
class="math inline">\(M\)</span> 中全体扭元的集合记为 <span
class="math inline">\(\mathrm{tor}(M)\)</span>。如果 <span
class="math inline">\(\mathrm{tor}(M)=M\)</span>，就说 <span
class="math inline">\(M\)</span> 是一个<strong>扭模</strong>，如果 <span
class="math inline">\(M\)</span> 中除了 <span
class="math inline">\(0\)</span> 以外没有扭元，就说 <span
class="math inline">\(M\)</span> 是一个<strong>无扭模</strong>。</p>
</div>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        (1,2) 关于理想的证明
    </div>
    <div class='spoiler-content'>
        <p>假设 <span class="math inline">\(N\)</span> 是子模，任取 <span
class="math inline">\(r\in \mathrm{ann}(N)\)</span>，任取 <span
class="math inline">\(x\in N\)</span>，再任取一个 <span
class="math inline">\(r_1\in R\)</span>。<br />
由于 <span class="math inline">\(rx=0\)</span>，<span
class="math inline">\((r_1r)x=r_1(rx)=r_10=0\)</span>，所以 <span
class="math inline">\(r_1r\in\mathrm{ann}(N)\)</span> 因而 <span
class="math inline">\(\mathrm{ann}(N)\)</span> 是左理想。</p>
<p>由于 <span class="math inline">\(N\)</span> 是子模，所以 <span
class="math inline">\(r_1x\in N\)</span>，所以 <span
class="math inline">\(r(r_1x)=0\)</span>。这意味着 <span
class="math inline">\(rr_1\in\mathrm{ann}(N)\)</span> 因而 <span
class="math inline">\(\mathrm{ann}(N)\)</span> 是右理想。这样一来 <span
class="math inline">\(\mathrm{ann}(N)\)</span> 就是双边理想。</p>

    </div>
</div>
<p>扭模的例子就是作为 <span class="math inline">\(\mathbb
Z\)</span>-模的 <span class="math inline">\(\mathbb Z_n\)</span>，因为
<span class="math inline">\(\mathbb Z_n\)</span> 中的每个元素乘以 <span
class="math inline">\(n\)</span> 之后都会变为 <span
class="math inline">\(0\)</span>。</p>
<div id="free-module" class="statement definition plain">
<p><span class="statement-heading"><span class="statement-label">定义
23</span>.</span><span class="statement-spah"> </span><span
class="math inline">\(\,\!\)</span><strong>（自由模）</strong><br />
假设 <span class="math inline">\(R\)</span> 是一个幺环，<span
class="math inline">\(M\)</span> 是一个左 <span
class="math inline">\(R\)</span>-模。如果 <span
class="math inline">\(M\)</span> 中存在 <span
class="math inline">\(n\)</span> 个元素 <span
class="math inline">\(u_1,u_2,\cdots,u_n\)</span> 使得：<br />
(1)<span class="math inline">\(\quad M\)</span> 可由 <span
class="math inline">\(u_1\sim u_n\)</span> 可生成，即 <span
class="math display">\[M=Ru_1+Ru_2+\cdots+Ru_n,\]</span> (2)<span
class="math inline">\(\quad u_1,u_2,\cdots,u_n\)</span> 线性无关，即
<span class="math display">\[\sum_{i=1}^n
r_iu_i=0\quad\Leftrightarrow\quad r_1=r_2=\cdots=r_n=0.\]</span> 就说
<span class="math inline">\(M\)</span>
是一个<strong>自由模</strong>，<span class="math inline">\(n\)</span>
称为这个自由模的秩，<span class="math inline">\(\{u_i\}_{i=1}^n\)</span>
称为这个自由模的基。</p>
</div>
<p>不难看出，如果将数域 <span class="math inline">\(F\)</span>
视为幺环，那么 <span class="math inline">\(F\)</span> 的自由模就是 <span
class="math inline">\(F\)</span>
上的有限维线性空间，因此自由模可视为是“幺环上的有限维线性空间”。实际上，自由模的等价刻画有：</p>
<div id="free-module-property" class="statement theorem plain">
<p><span class="statement-heading"><span class="statement-label">定理
24</span>.</span><span class="statement-spah"> </span><span
class="math inline">\(\,\!\)</span> 假设 <span
class="math inline">\(R\)</span> 是幺环，<span
class="math inline">\(M\)</span> 是一个左 <span
class="math inline">\(R\)</span>-模，<span
class="math inline">\(u_1,u_2,\cdots,u_n\in M\)</span>，那么：<br />
(1)<span class="math inline">\(\quad M\)</span> 是自由模 <span
class="math inline">\(\quad\Leftrightarrow\quad M\)</span> 同构于作为左
<span class="math inline">\(R\)</span>-模的 <span
class="math inline">\(R^n\)</span>。<br />
(2)<span class="math inline">\(\quad M\)</span> 是以 <span
class="math inline">\(u_1,u_2,\cdots,u_n\)</span> 为基的自由模 <span
class="math inline">\(\quad\Leftrightarrow\quad\)</span> 对任意一个左
<span class="math inline">\(R\)</span> 模 <span
class="math inline">\(M&#39;\)</span> 及其中的 <span
class="math inline">\(n\)</span> 个元素 <span
class="math inline">\(v_1&#39;,v_2&#39;,\cdots,v_n&#39;\)</span>，都存在唯一的一个从
<span class="math inline">\(M\)</span> 到 <span
class="math inline">\(M&#39;\)</span> 的模同态 <span
class="math inline">\(\sigma\)</span>，它满足 <span
class="math inline">\(\sigma(u_i)=v_i&#39;\)</span>。</p>
</div>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        证明
    </div>
    <div class='spoiler-content'>
        <p>(1)<span class="math inline">\(\quad\)</span>对于“<span
class="math inline">\(\Rightarrow\)</span>”，假设 <span
class="math inline">\(u_1,u_2,\cdots,u_n\in M\)</span> 是自由模 <span
class="math inline">\(M\)</span> 的一组基，考虑从 <span
class="math inline">\(M\)</span> 到 <span
class="math inline">\(R^n\)</span> 的模同态 <span
class="math inline">\(\sigma\left(\sum_{i}r_iu_i\right)=(r_1,r_2,\cdots,r_n)\)</span>，不难发现
<span class="math inline">\(\mathrm{ker}(\sigma)=\{0\}\)</span>，<span
class="math inline">\(\mathrm{im}(\sigma)=R^n\)</span>，因此 <span
class="math inline">\(M\simeq R^n\)</span>。对于“<span
class="math inline">\(\Leftarrow\)</span>”，考虑从 <span
class="math inline">\(R^n\)</span> 到 <span
class="math inline">\(M\)</span> 的模同态 <span
class="math inline">\(\sigma\left((r_1,r_2,\cdots,r_n)\right)=\sum_{i}r_iu_i\)</span>
即可。</p>
<p>(2, “<span class="math inline">\(\Rightarrow\)</span>”)<span
class="math inline">\(\quad\)</span>考虑从 <span
class="math inline">\(M\)</span> 到 <span
class="math inline">\(M&#39;\)</span> 的映射 <span
class="math inline">\(\sigma\left(\sum_{i}r_iu_i\right)=\sum_{i}r_iv_i&#39;\)</span>，验证其为模同态及其唯一性即可。<br />
(2, “<span class="math inline">\(\Leftarrow\)</span>”)<span
class="math inline">\(\quad\)</span>取 <span
class="math inline">\(M&#39;=Ru_1+\cdots+Ru_n\)</span> 以及 <span
class="math inline">\(v_i&#39;=u_i\)</span>，于是存在模同态 <span
class="math inline">\(\sigma\)</span> 满足 <span
class="math inline">\(\sigma(u_i)=u_i\)</span>。不难发现 <span
class="math inline">\(M&#39;\)</span> 是 <span
class="math inline">\(M\)</span> 的子模，<span
class="math inline">\(\sigma\)</span> 在 <span
class="math inline">\(M&#39;\)</span> 上的限制正是 <span
class="math inline">\(M&#39;\)</span> 上的恒同映射 <span
class="math inline">\(\mathrm{id}|_{M&#39;}\)</span>。考虑到 <span
class="math inline">\(M\)</span> 上的恒同映射 <span
class="math inline">\(\mathrm{id}|_{M}\)</span> 在 <span
class="math inline">\(M&#39;\)</span> 上的限制也是 <span
class="math inline">\(\mathrm{id}|_{M&#39;}\)</span>，而 <span
class="math inline">\(\sigma\)</span> 是唯一的，所以 <span
class="math inline">\(\sigma=\mathrm{id}\)</span>，即 <span
class="math inline">\(M\)</span> 由 <span class="math inline">\(u_1\sim
u_n\)</span> 生成。然后再取 <span
class="math inline">\(M&#39;=R^n\)</span>，<span
class="math inline">\(\{v_i&#39;\}\)</span> 为全体 <span
class="math inline">\((0,\cdots,0,1,0,\cdots,0)\)</span>
构成的基矢，这样一来可发现 <span class="math inline">\(M\simeq
R^n\)</span> 因而是自由模。</p>

    </div>
</div>
<p>定理 <a href="#free-module-property" title="24">24</a>(2)
实际上告诉我们，所有的有限生成模都是一个自由模的同态像。</p>
<p>以下提供一些奇怪的反例。无扭模不一定是自由模：</p>
<div id="Q-is-not-free-module"
class="statement example definition unnumbered">
<p><span class="statement-heading"><span
class="statement-label">例子</span>：</span><span
class="statement-spah"> </span><span class="math inline">\(\,\!\)</span>
考虑作为 <span class="math inline">\(\mathbb Z\)</span>-模的有理数 <span
class="math inline">\(\mathbb Q\)</span> 加法群。显然 <span
class="math inline">\(\mathbb Q\)</span> 中除了 <span
class="math inline">\(0\)</span> 以外没有扭元。但是 <span
class="math inline">\(\mathbb Q\)</span> 不可能由有限个有理数 <span
class="math inline">\(u_i\)</span> 生成：一组 <span
class="math inline">\(u_i\)</span> 只能生成 <span
class="math inline">\(1/u\)</span> 的倍数，其中 <span
class="math inline">\(u\)</span> 是约分后的 <span
class="math inline">\(u_i\)</span> 的分母们的最小公倍数。</p>
</div>
<p>有限生成模的子模不一定是有限生成的：</p>
<div id="sub-module-is-not-finite-module"
class="statement example definition unnumbered">
<p><span class="statement-heading"><span
class="statement-label">例子</span>：</span><span
class="statement-spah"> </span><span class="math inline">\(\,\!\)</span>
考虑全体形如 <span class="math inline">\(\begin{bmatrix}\mathbb
Z&amp;\mathbb Q\\ 0&amp;\mathbb Q\end{bmatrix}\)</span>
的矩阵，它显然构成一个环 <span
class="math inline">\(R\)</span>，因而也能构成自己的左模，并且是有限生成的秩为
<span class="math inline">\(1\)</span> 的自由模。形如 <span
class="math inline">\(\begin{bmatrix}0&amp;\mathbb Q\\
0&amp;0\end{bmatrix}\)</span>
的矩阵构成它的子模。这一子模不是有限生成的。</p>
</div>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        证明
    </div>
    <div class='spoiler-content'>
        <p>由于 <span class="math display">\[\begin{bmatrix}\mathbb
Z&amp;\mathbb Q\\ 0&amp;\mathbb
Q\end{bmatrix}\begin{bmatrix}0&amp;\mathbb Q\\
0&amp;0\end{bmatrix}=\begin{bmatrix}0&amp;\mathbb Z\mathbb Q\\
0&amp;0\end{bmatrix},\]</span> 可以看出 <span
class="math inline">\(\begin{bmatrix}0&amp;\mathbb Q\\
0&amp;0\end{bmatrix}\)</span> 确实是左模。由于 <span
class="math inline">\(\mathbb Q\)</span> 并不是 <span
class="math inline">\(\mathbb Z\)</span> 上的有限生成模，所以 <span
class="math inline">\(\begin{bmatrix}0&amp;\mathbb Q\\
0&amp;0\end{bmatrix}\)</span> 不是有限生成的。</p>

    </div>
</div>
<p>自由模不一定是无扭模，并且自由模的子模也不一定是自由模：</p>
<div id="sub-module-is-not-free-module"
class="statement example definition unnumbered">
<p><span class="statement-heading"><span
class="statement-label">例子</span>：</span><span
class="statement-spah"> </span><span class="math inline">\(\,\!\)</span>
考虑两个 <span class="math inline">\(\mathbb Z\)</span> 的笛卡尔积 <span
class="math inline">\(\mathbb Z\times\mathbb Z\)</span>。<span
class="math inline">\(\mathbb Z\times\mathbb Z\)</span>
可以视为是自己的自由模且秩为 <span
class="math inline">\(1\)</span>，基底由 <span
class="math inline">\((1,1)\)</span> 构成——注意，<span
class="math inline">\((0,1)\)</span> 和 <span
class="math inline">\((1,0)\)</span> 并不能构成基底因为此时 <span
class="math inline">\((0,0)\)</span> 的表示方法不唯一。不难看出，<span
class="math inline">\(\mathbb Z\times\mathbb Z\)</span>
是自由模但不是无扭模因为 <span
class="math inline">\((0,1)(1,0)=(0,0)\)</span>，而 <span
class="math inline">\((\mathbb Z\times\mathbb Z)(1,0)\)</span> 构成
<span class="math inline">\(\mathbb Z\times\mathbb Z\)</span>
的子模但不是自由模。注意 <span class="math inline">\(\mathbb
Z\times\mathbb Z\)</span> 不是整环。</p>
</div>
<p>但是，主理想整环（PID）上的模不会有那么多的幺蛾子：</p>
<p><span id="PID-submodule"></p>
<div id="sub-module-of-free-PID-module-is-free-module"
class="statement theorem plain">
<p><span class="statement-heading"><span class="statement-label">定理
25</span>.</span><span class="statement-spah"> </span><span
class="math inline">\(\,\!\)</span><br />
(1)<span
class="math inline">\(\quad\)</span>整环上的自由模一定是无扭模。<br />
(2)<span class="math inline">\(\quad\)</span>PID
上自由模的子模一定也是有限生成的自由模。<br />
(3)<span class="math inline">\(\quad\)</span>PID
上有限生成的无扭模都是自由模。<br />
(4)<span class="math inline">\(\quad\)</span>PID
上有限生成模的子模都是有限生成的。</p>
</div>
<p></span></p>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        跳转到
    </div>
    <div class='spoiler-content'>
        <p><a href="#PID-finite-generated-module-3">初等因子分解</a></p>

    </div>
</div>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        证明思路
    </div>
    <div class='spoiler-content'>
        <p>(1)<span class="math inline">\(\quad\)</span>假设 <span
class="math inline">\(R\)</span> 是整环，<span
class="math inline">\(M\)</span> 是自由的左 <span
class="math inline">\(R\)</span>-模，<span class="math inline">\(u_1\sim
u_n\)</span> 是 <span class="math inline">\(M\)</span> 的基底。假设
<span class="math inline">\(r\left(\sum_i r_iu_i\right)=0\)</span>，其中
<span class="math inline">\(r,r_i\in R\)</span>。由于 <span
class="math inline">\(M\)</span> 是自由模，所以 <span
class="math inline">\(rr_i=0\)</span>。由于 <span
class="math inline">\(R\)</span> 是整环，所以必有 <span
class="math inline">\(r=0\)</span> 或全体 <span
class="math inline">\(r_i=0\)</span>，因此 <span
class="math inline">\(M\)</span> 中没有扭元。</p>
(2)<span class="math inline">\(\quad\)</span>假设 <span
class="math inline">\(R\)</span> 是 PID，<span
class="math inline">\(M\)</span> 是自由的左 <span
class="math inline">\(R\)</span>-模，<span class="math inline">\(u_1\sim
u_n\)</span> 是 <span class="math inline">\(M\)</span> 的基底。将 <span
class="math inline">\(N\)</span> 中所有元素的 <span
class="math inline">\(u_i\)</span> 分量构成的集合记为 <span
class="math inline">\(I_i\)</span>： <span
class="math display">\[I_i=\{r_i:\quad r_1u_1+\cdots+r_nu_n\in
N\}.\]</span> 由于 <span class="math inline">\(N\)</span> 是子模即 <span
class="math inline">\(rN\subset N\)</span>，所以 <span
class="math inline">\(I_i\)</span> 构成理想。由于 <span
class="math inline">\(R\)</span> 是 PID 所以可假设 <span
class="math inline">\(I_i=(d_i)\)</span>，这意味着 <span
class="math inline">\(N\)</span> 中必然存在一个元素 <span
class="math inline">\(f_1\)</span>，其 <span
class="math inline">\(u_1\)</span> 分量为 <span
class="math inline">\(d_1\)</span>： <span
class="math display">\[f_1=d_1u_1+\sum_{i=2}^nr_i&#39;u_i\]</span>
再考虑
<center>
<span class="math inline">\(N&#39;:=Rf_1+(M_1\cap
N),\quad\)</span>其中<span
class="math inline">\(\;\;M_1:=\displaystyle\sum_{i=2}^nRu_i=\bigoplus_{i=2}^nRu_i.\)</span>
</center>
<p>由于 <span class="math inline">\(f_1\in N\)</span> 而 <span
class="math inline">\(N\)</span> 是子模所以 <span
class="math inline">\(Rf_1\subset N\)</span>。考虑到 <span
class="math inline">\((M_1\cap N)\subset N\)</span>。因此 <span
class="math inline">\(N&#39;\subset N\)</span>。<br />
从 <span class="math inline">\(N\)</span> 中任取一个元素 <span
class="math inline">\(x\)</span>，假设 <span
class="math inline">\(x\)</span> 的 <span
class="math inline">\(u_1\)</span> 分量为 <span
class="math inline">\(a_1d_1\)</span>。那么 <span
class="math inline">\(x-a_1f_1\)</span> 将不会有 <span
class="math inline">\(u_1\)</span> 分量，因此 <span
class="math inline">\(x-a_1f_1\in (M_1\cap N)\)</span>。显然 <span
class="math inline">\(a_1f_1\in Rf_1\)</span>，所以 <span
class="math inline">\(N\)</span> 中的任两个元素都可写为 <span
class="math inline">\(Rf_1\)</span> 与 <span
class="math inline">\((M_1\cap N)\)</span> 中元素的和，因此 <span
class="math inline">\(N\subset N&#39;\)</span>。<br />
这样一来，我们证明了 <span class="math inline">\(N=N&#39;\)</span>，即
<span class="math inline">\(N=Rf_1+(M_1\cap N)\)</span>。考虑到 <span
class="math inline">\((M_1\cap N)\)</span> 中的元素除了 <span
class="math inline">\(0\)</span> 以外不会有 <span
class="math inline">\(u_1\)</span> 分量，而 <span
class="math inline">\(Rf_1\)</span> 只有 <span
class="math inline">\(0\)</span> 没有 <span
class="math inline">\(u_1\)</span> 分量，因此 <span
class="math inline">\(Rf_1\cap(M_1\cap N)=\{0\}\)</span>。至此我们证明了
<span class="math inline">\(N=Rf_1\oplus(M_1\cap N)\)</span>。</p>
<p>实际上，<span class="math inline">\(M_1\cap N\)</span> 也是子模。如果
<span class="math inline">\(M_1\cap N\)</span> 中有 <span
class="math inline">\(u_2\)</span> 分量不为 <span
class="math inline">\(0\)</span> 的矢量 <span
class="math inline">\(f_2\)</span>，那么我们也可以对它使用以上步骤，将其分解为
<span class="math inline">\(Rf_2\oplus(M_2\cap N)\)</span>，其中 <span
class="math inline">\(M_2:=\sum_{i=3}^nRu_i\)</span>。如果 <span
class="math inline">\(M_1\cap N\)</span> 中的元素全都没有 <span
class="math inline">\(u_2\)</span> 分量——例如 <span
class="math inline">\(N=R(u_1+u_2)\)</span> 就是这种情况——那么就依次考虑
<span class="math inline">\(u_3,u_4,\cdots\)</span>
分量，再进行以上步骤。这样的步骤总会再有限步之后终止，这样就能够证明
<span class="math inline">\(N=Rf_1\oplus\cdots\oplus Rf_r\)</span>，即
<span class="math inline">\(N\)</span> 是自由模。</p>
<p>以上只是一个证明思路，严格的证明可通过数学归纳法完成。</p>
<p>(3)<span class="math inline">\(\quad\)</span>假设 <span
class="math inline">\(R\)</span> 是 PID，<span
class="math inline">\(M\)</span> 是由 <span
class="math inline">\(u_1\sim u_m\)</span> 生成的无扭模。假设 <span
class="math inline">\(u_1\sim u_r\)</span> 线性无关，且 <span
class="math inline">\(u_{r+1}\sim u_m\)</span> 可由 <span
class="math inline">\(u_1\sim u_r\)</span> “线性表出”： <span
class="math display">\[a_iu_{r+i}=\sum_{j=1}^r r_{i,j} u_j.\]</span>
显然，<span class="math inline">\(a:=a_1a_2\cdots a_{m-r}\neq
0\)</span>，否则 <span class="math inline">\(u_1\sim u_r\)</span>
将线性相关。考虑从 <span class="math inline">\(M\)</span> 到 <span
class="math inline">\(M\)</span> 的模同态： <span
class="math display">\[\eta(m)=am.\]</span> <span
class="math inline">\(M\)</span> 是无扭模所以 <span
class="math inline">\(\mathrm{ker}\eta=\{0\}\)</span>。而 <span
class="math inline">\(\mathrm{im}\eta\)</span> 是 PID 上的自由模 <span
class="math inline">\(Ru_1+Ru_2+\cdots+Ru_r\)</span>
的子模因而也是自由模。再由同态基本定理可以证明 <span
class="math inline">\(M\)</span> 是自由模。</p>
<p>(4)<span class="math inline">\(\quad\)</span>假设 <span
class="math inline">\(R\)</span> 是 PID，<span
class="math inline">\(M\)</span> 是由 <span
class="math inline">\(u_1\sim u_m\)</span> 生成的有限生成模，<span
class="math inline">\(N\)</span> 是 <span
class="math inline">\(M\)</span> 的子模。<span
class="math inline">\(M_0\)</span> 是一个秩为 <span
class="math inline">\(m\)</span> 的自由模，其基为 <span
class="math inline">\(e_1\sim e_m\)</span>。那么存在唯一的一个从 <span
class="math inline">\(M_0\)</span> 到 <span
class="math inline">\(M\)</span> 的模同态 <span
class="math inline">\(\eta\)</span> 使得 <span
class="math inline">\(\eta(e_i)=u_i\)</span>。考虑 <span
class="math inline">\(\eta^{-1}(N)\)</span>，即 <span
class="math inline">\(N\)</span> 的原像，显然它是 <span
class="math inline">\(M_0\)</span> 的子模，因而也是自由模。假设 <span
class="math inline">\(f_1\sim f_r\)</span> 是 <span
class="math inline">\(\eta^{-1}(N)\)</span> 的基，那么 <span
class="math inline">\(\eta(f_i)\)</span> 就是 <span
class="math inline">\(N\)</span> 的基，因此 <span
class="math inline">\(N\)</span> 也是有限生成的。</p>

    </div>
</div>
<h2 id="主理想整环上有限生成模的结构">主理想整环上有限生成模的结构</h2>
<p>我们首先引入几个记号：</p>
<div id="PID-prime-component" class="statement definition plain">
<p><span class="statement-heading"><span class="statement-label">定义
24</span>.</span><span class="statement-spah"> </span><span
class="math inline">\(\,\!\)</span><strong>（<span
class="math inline">\(p\)</span> 模与 <span
class="math inline">\(p\)</span> 分量）</strong><br />
假设 <span class="math inline">\(R\)</span> 是 PID，<span
class="math inline">\(M\)</span> 是左 <span
class="math inline">\(R\)</span>-模，<span
class="math inline">\(p\)</span> 是 <span
class="math inline">\(R\)</span> 中的素元<br />
(1)<span class="math inline">\(\quad\)</span>假设 <span
class="math inline">\(a\in R\)</span>，那么 <span
class="math inline">\(M(a):=\{m\in M:\quad am=0\}\)</span>。<br />
(2)<span class="math inline">\(\quad\)</span>假设 <span
class="math inline">\(N\)</span> 是 <span
class="math inline">\(M\)</span> 的子集，那么 <span
class="math inline">\(\mathrm{ann}(N):=\bigcap_{x\in
N}\mathrm{ann}(x)\)</span>。<br />
(3)<span class="math inline">\(\quad M\)</span> 的 <strong><span
class="math inline">\(p\)</span> 分量</strong> <span
class="math inline">\(M_p\)</span> 定义为 <span
class="math inline">\(M_p:=\bigcup_{n=1}^\infty M(p^n)\)</span>，即
<span class="math inline">\(M_p\)</span> 中的元素总能被 <span
class="math inline">\(p\)</span> 的某次方零化。如果 <span
class="math inline">\(M=M_p\)</span> 就说 <span
class="math inline">\(M\)</span> 是一个 <strong><span
class="math inline">\(p\)</span> 模</strong>。</p>
</div>
<p>关于 PID 上的有限生成模，有如下基本定理：</p>
<div id="PID-finite-generated-module" class="statement theorem plain">
<p><span class="statement-heading"><span class="statement-label">定理
26</span>.</span><span class="statement-spah"> </span><span
class="math inline">\(\,\!\)</span><strong>（主理想整环上有限生成模的结构定理）</strong><br />
假设 <span class="math inline">\(R\)</span> 是 PID，<span
class="math inline">\(M\)</span> 是 <span
class="math inline">\(R\)</span> 上的有限生成模，<span
class="math inline">\(p\)</span> 与 <span
class="math inline">\(p_i\)</span> 是 <span
class="math inline">\(R\)</span> 中的素元，那么：<br />
(1)<span class="math inline">\(\quad\)</span> <span
class="math inline">\(\mathrm{tor}(M)\)</span> 是 <span
class="math inline">\(M\)</span> 的子模，且 <span
class="math inline">\(M\simeq \mathrm{tor}(M)\oplus
M/\mathrm{tor}(M)\)</span>，其中 <span
class="math inline">\(M/\mathrm{tor}(M)\)</span>
是有限生成的自由模且同构于 <span class="math inline">\(M\)</span>
的子模。<br />
(2)<span
class="math inline">\(\quad\)</span><strong>（准素分解）</strong> <span
class="math inline">\(\mathrm{tor}(M)\)</span> 可分解为一系列形如 <span
class="math inline">\(M(p_i^{n_i})\)</span> 的 <span
class="math inline">\(p_i\)</span> 模的直和。<br />
(3)<span
class="math inline">\(\quad\)</span><strong>（初等因子分解）</strong> 在
<span class="math inline">\(M\)</span> 的准素分解中每一个形如 <span
class="math inline">\(M(p_i^{n_i})\)</span> 的 <span
class="math inline">\(p_i\)</span> 模都可分解为一系列循环 <span
class="math inline">\(p_i\)</span> 模的直和：<span
class="math inline">\(M(p_i^{n_i})=\bigoplus_{j=1}^{s_i}Ru_{i,j}\simeq\bigoplus_{j=1}^{s_i}R/(p_i^{k_{i,j}})\)</span>，其中
<span
class="math inline">\(\mathrm{ann}(u_{i,j})=(p_i^{k_{i,j}})\)</span>，<span
class="math inline">\(k_{i,j}\geqslant1\)</span>。全体 <span
class="math inline">\(p_i^{k_{i,j}}\)</span> 构成的集合称为 <span
class="math inline">\(M\)</span> 的<strong>初等因子</strong>。<br />
(4)<span
class="math inline">\(\quad\)</span><strong>（不变因子分解）</strong>
<span class="math inline">\(\mathrm{tor}(M)\)</span> 可分解为一系列
<span class="math inline">\(Rv_i\simeq R/(d_i)\)</span> 的直和，其中
<span class="math inline">\(\mathrm{ann}(v_i)=(d_i)\)</span>，并且 <span
class="math inline">\(d_i|d_{i+1}\)</span>。全体 <span
class="math inline">\(d_i\)</span> 构成的集合称为 <span
class="math inline">\(M\)</span> 的<strong>不变因子</strong>。<br />
(5)<span class="math inline">\(\quad\)</span>初等因子与不变因子在 PID
中的相伴的意义下都是唯一的。</p>
</div>
<p>以下我们逐步证明这一定理。</p>
<p>首先：</p>
<div id="PID-finite-generated-module-1"
class="unnumbered statement theorem-unnumbered plain">
<p><span class="statement-heading"><span
class="statement-label">定理</span>.</span><span class="statement-spah">
</span><span class="math inline">\(\,\!\)</span> 假设 <span
class="math inline">\(R\)</span> 是 PID，<span
class="math inline">\(M\)</span> 是 <span
class="math inline">\(R\)</span> 上的有限生成模，那么 <span
class="math inline">\(\mathrm{tor}(M)\)</span> 是 <span
class="math inline">\(M\)</span> 的子模，<span
class="math inline">\(M/\mathrm{tor}(M)\)</span>
是有限生成的自由模，<span class="math inline">\(M\simeq
\mathrm{tor}(M)\oplus M/\mathrm{tor}(M)\)</span>。</p>
</div>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        证明
    </div>
    <div class='spoiler-content'>
        <p>step-(1)<span class="math inline">\(\quad\)</span>如果 <span
class="math inline">\(R\)</span> 是交换环，那么 <span
class="math inline">\(\mathrm{tor}(M)\)</span> 可以构成 <span
class="math inline">\(M\)</span> 的子模：假如 <span
class="math inline">\(r_1m_1=r_2m_2=0\)</span>，那么 <span
class="math inline">\(r_1r_2(m_1+m_2)=r_2r_1m_1+r_1r_2m_2=0\)</span>，即
<span class="math inline">\(m_1+m_2\in\mathrm{tor}(M)\)</span>。</p>
<p>step-(2)<span class="math inline">\(\quad\)</span>现在证明 <span
class="math inline">\(M/\mathrm{tor}(M)\)</span> 没有扭元。假如 <span
class="math inline">\(M/\mathrm{tor}(M)\)</span> 中有扭元 <span
class="math inline">\(\bar a=a+\mathrm{tor}(M)\)</span>，即存在不为
<span class="math inline">\(0\)</span> 的 <span
class="math inline">\(r\)</span> 使得 <span class="math inline">\(r\bar
a=\bar 0\)</span>，那么 <span class="math inline">\(ra\in
\mathrm{tor}(M)\)</span>。因此存在 <span class="math inline">\(r&#39;\in
R\)</span> 且 <span class="math inline">\(r&#39;\neq0\)</span> 使得
<span class="math inline">\(r&#39;ra=0\)</span>。由于 <span
class="math inline">\(M\)</span> 中没有扭元，所以 <span
class="math inline">\(r&#39;r=0\)</span>，这与 <span
class="math inline">\(r,r&#39;\)</span> 都不为 <span
class="math inline">\(0\)</span> 矛盾。</p>
<p>step-(3)<span class="math inline">\(\quad\)</span>不难看出，<span
class="math inline">\(M/\mathrm{tor}(M)\)</span> 是有限生成的：取 <span
class="math inline">\(M\)</span> 的生成元 <span
class="math inline">\(u_1\sim u_m\)</span>，那么 <span
class="math inline">\(M/\mathrm{tor}(M)\)</span> 的生成元一定也是 <span
class="math inline">\(\bar u_1\sim\bar u_m\)</span> 的子集。由于 <span
class="math inline">\(M/\mathrm{tor}(M)\)</span> 是 PID
上有限生成的无扭模，所以它也是自由模。</p>
<p>step-(4)<span class="math inline">\(\quad\)</span>由于 <span
class="math inline">\(M/\mathrm{tor}(M)\)</span> 是自由模，所以它有基底
<span class="math inline">\(\bar v_1\sim\bar v_r\)</span>，然后考虑
<span class="math inline">\(M\)</span> 中的子模 <span
class="math inline">\(N:=Rv_1+\cdots+Rv_r\)</span>。根据 <span
class="math inline">\(M/\mathrm{tor}(M)\)</span> 与 <span
class="math inline">\(\mathrm{tor}(M)\)</span> 的定义不难看出 <span
class="math inline">\(M=N+\mathrm{tor}(M)\)</span>，以及 <span
class="math inline">\(N\cap\mathrm{tor}(M)=\{0\}\)</span>，因此 <span
class="math inline">\(M=N\oplus\mathrm{tor}(M)\)</span>。</p>

    </div>
</div>
<p>主理想整环 <span class="math inline">\(R\)</span> 上的自由模同构于
<span class="math inline">\(R^n\)</span>，因而现在的问题是分析 <span
class="math inline">\(\mathrm{tor}(M)\)</span> 的结构。对此，有：</p>
<div id="PID-finite-generated-module-2"
class="unnumbered statement theorem-unnumbered plain">
<p><span class="statement-heading"><span
class="statement-label">定理</span>.</span><span class="statement-spah">
</span><span class="math inline">\(\,\!\)</span> 如果 <span
class="math inline">\(R\)</span> 是 PID，<span
class="math inline">\(M\)</span> 是 <span
class="math inline">\(R\)</span> 上的有限生成扭模，<span
class="math inline">\(\mathrm{ann}(M)\)</span> 是 <span
class="math inline">\(R\)</span> 的理想且 <span
class="math inline">\(\mathrm{ann}(M)=(a)\)</span>，<span
class="math inline">\(a\)</span> 又有因子分解 <span
class="math inline">\(a=p_1^{n_1}p_2^{n_2}\cdots p_k^{n_k}\)</span> 其中
<span class="math inline">\(p_i\)</span> 都是素元或不可约元，那么 <span
class="math inline">\(M=M(p_1^{n_1})\oplus\cdots\oplus
M(p_k^{n_k})\)</span>。</p>
</div>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        证明
    </div>
    <div class='spoiler-content'>
        <p>由于 <span class="math inline">\(M(p_1^{n_1})+\cdots+
M(p_k^{n_k})\)</span> 中的元素显然都被 <span
class="math inline">\(a\)</span> 零化，因此 <span
class="math inline">\(M(p_1^{n_1})+\cdots+ M(p_k^{n_k})\subset
M\)</span>。</p>
<p>由于 <span class="math inline">\(p_i\)</span> 之间彼此互素，所以
<span class="math inline">\(a/p_i^{n_i}\)</span>
之间也彼此互素，所以存在一系列 <span class="math inline">\(b_i\)</span>
使得 <span class="math inline">\(\sum_{i=1}^k
b_ia/p_i^{n_i}=1\)</span>。从扭模 <span class="math inline">\(M\)</span>
中任取一个元素 <span class="math inline">\(x\)</span>。那么： <span
class="math display">\[x=\sum_{i=1}^k
b_i(a/p_i^{n_i})x:=\sum_{i=1}^kx_i.\]</span> 不难看出，<span
class="math inline">\(x_i\in M(p_i^{n_i})\)</span>，因此 <span
class="math inline">\(M\subset M(p_1^{n_1})+\cdots+
M(p_k^{n_k})\)</span>。</p>
<p>这样一来就证明了 <span class="math inline">\(M(p_1^{n_1})+\cdots+
M(p_k^{n_k})=M\)</span>。</p>
<p>现在证明 <span
class="math inline">\(M(p_1^{n_1})\cap\left[M(p_2^{n_2})+\cdots+
M(p_k^{n_k})\right]=\{0\}\)</span>。从这一交集中任取一个元素 <span
class="math inline">\(f\)</span>，将它拆解为 <span
class="math inline">\(M(p_2^{n_2})\sim M(p_k^{n_k})\)</span>
中元素的和：<span class="math inline">\(f=f_2+\cdots+f_n\)</span>。由于
<span class="math inline">\(p_1^{n_1}\)</span> 与 <span
class="math inline">\(p_2^{n_2}\cdots p_k^{n_k}\)</span> 互素，所以存在
<span class="math inline">\(a,b\)</span> 使得 <span
class="math inline">\(ap_1^{n_1}+bp_2^{n_2}\cdots
p_k^{n_k}=1\)</span>，于是 <span
class="math display">\[f=(ap_1^{n_1}+bp_2^{n_2}\cdots
p_k^{n_k})f=0+0=0.\]</span></p>
<p>同理可证 <span
class="math inline">\(M(p_i^{n_i})\cap\left[\sum_{j\neq
i}^kM(p_j^{n_j})\right]=\{0\}\)</span>。所以 <span
class="math inline">\(M=M(p_1^{n_1})\oplus\cdots\oplus
M(p_k^{n_k})\)</span>。</p>

    </div>
</div>
<p>以上定理将扭模 <span class="math inline">\(\mathrm{tor}(M)\)</span>
分解为一系列 <span class="math inline">\(p\)</span> 模。现在我们说明
<span class="math inline">\(p\)</span> 模可以分解为一系列循环 <span
class="math inline">\(p\)</span> 模，且这种分解是唯一的。</p>
<p><span id="PID-finite-generated-module-3"></p>
<div id="PID-finite-generated-module-3"
class="unnumbered statement theorem-unnumbered plain">
<p><span class="statement-heading"><span
class="statement-label">定理</span>.</span><span class="statement-spah">
</span><span class="math inline">\(\,\!\)</span><br />
(1)<span class="math inline">\(\quad\)</span>如果 <span
class="math inline">\(R\)</span> 是 PID，<span
class="math inline">\(M_p\)</span> 是 <span
class="math inline">\(R\)</span> 上有限生成的 <span
class="math inline">\(p\)</span> 模，那么存在一系列 <span
class="math inline">\(\geqslant1\)</span> 的 <span
class="math inline">\(m_j\)</span> 满足 <span
class="math inline">\(M_p=\bigoplus_{j=1}^{k}Ru_{j}\simeq\bigoplus_{j=1}^{k}R/(p^{m_{j}})\)</span>，其中
<span
class="math inline">\(\mathrm{ann}(u_{j})=(p^{m_{j}})\)</span>。<br />
(2)<span class="math inline">\(\quad\)</span>以上分解中的 <span
class="math inline">\(\{m_j\}\)</span> 是唯一的。</p>
</div>
<p></span></p>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        (1) 的证明
    </div>
    <div class='spoiler-content'>
        <p>假设 <span class="math inline">\(M_p\)</span> 由 <span
class="math inline">\(u_1\sim u_n\)</span>
生成。我们知道，任何有限生成模都是一个自由模的同态像，因此我们取一个基底为
<span class="math inline">\(e_1\sim e_n\)</span> 的自由模 <span
class="math inline">\(M\)</span>，那么存在唯一的一个模同态 <span
class="math inline">\(\eta\)</span> 满足 <span
class="math inline">\(\eta(e_i)=u_i\)</span>，以及 <span
class="math inline">\(M_p\simeq M/\mathrm{ker}\,\eta\)</span>。由于
<span class="math inline">\(\mathrm{ker}\,\eta\)</span> 是 <span
class="math inline">\(M\)</span> 的子模，所以也是自由模。</p>
<p>只要我们能够证明 <span
class="math inline">\(\mathrm{ker}\,\eta\)</span> 中有一组基为 <span
class="math inline">\(p^{m_1}e_1\sim p^{m_n}e_n\)</span>，就有： <span
class="math display">\[\begin{align*}\begin{split}
M_p&amp;\simeq M/\mathrm{ker}\,\eta\simeq (Re_1\oplus\cdots\oplus
Re_n)/(Rp^{m_1}e_1\oplus\cdots\oplus Rp^{m_n}e_n)\\
&amp;\simeq (Re_1/Rp^{m_1}e_1)\oplus\cdots\oplus
(Re_n/Rp^{m_n}e_n)\end{split}\end{align*}\]</span> <span
class="math inline">\(m_i=0\)</span> 的直和因子可以直接扔掉。对于 <span
class="math inline">\(\geqslant1\)</span> 的 <span
class="math inline">\(m_i\)</span>，不难看出，<span
class="math inline">\(Re_i/Rp^{m_i}e_i\simeq R/(p^{m_i})\)</span> 为循环
<span class="math inline">\(p\)</span> 模，其生成元 <span
class="math inline">\(\bar e_i=e_i+Rp^{m_i}e_i\)</span> 满足 <span
class="math inline">\(p^{m_i}\bar e_i=\bar 0\)</span>，即 <span
class="math inline">\(\mathrm{ann}(\bar
e_i)=(p^{m_i})\)</span>。这样就证明了 (1)。</p>
<hr />
<p>现在我们证明 <span class="math inline">\(\mathrm{ker}\,\eta\)</span>
中有一组基为 <span class="math inline">\(p^{m_1}e_1\sim
p^{m_n}e_n\)</span>。证明方法为对 <span class="math inline">\(M\)</span>
的秩 <span class="math inline">\(n\)</span> 做数学归纳法，证明思路与证明
<a href="#PID-submodule">PID
上自由模的子模一定也是自由模</a>时一样。</p>
<p>为 <span class="math inline">\(M\)</span> 选另一组基 <span
class="math inline">\(f_1\sim f_n\)</span>。并将 <span
class="math inline">\(\mathrm{ker}\,\eta\)</span> 记为 <span
class="math inline">\(N\)</span>。将 <span
class="math inline">\(N\)</span> 中所有元素的 <span
class="math inline">\(f_i\)</span> 分量构成的集合记为 <span
class="math inline">\(I_i\)</span>： <span
class="math display">\[I_i=\{r_i:\quad r_1f_1+\cdots+r_nf_n\in
N\}.\]</span> 由于 <span class="math inline">\(N\)</span> 是子模即 <span
class="math inline">\(rN\subset N\)</span>，所以 <span
class="math inline">\(I_i\)</span> 构成理想。由于 <span
class="math inline">\(R\)</span> 是 PID 所以可假设 <span
class="math inline">\(I_i=(d_i)\)</span>。</p>
<p>从 <span class="math inline">\(M/N\)</span> 中任取一个元素 <span
class="math inline">\(\bar a:=a+N\)</span>，由于 <span
class="math inline">\(M/N\)</span> 是 <span
class="math inline">\(p\)</span> 模，所以存在 <span
class="math inline">\(p^n\)</span> 使得 <span
class="math inline">\(p^n\bar a=\bar 0\)</span>，即 <span
class="math inline">\(p^na\in N\)</span>。分别取 <span
class="math inline">\(a=e_1\sim e_n\)</span>，那么也存在一系列 <span
class="math inline">\(n_i\)</span> 使得 <span
class="math inline">\(p^{n_i}e_i\in n\)</span>，所以 <span
class="math inline">\(d_i|p^{n_i}\)</span>。这意味着所有的 <span
class="math inline">\(d_i\)</span> 只能具有 <span
class="math inline">\(p^{m_i}\)</span> 的形式。</p>
不妨设所有 <span class="math inline">\(m_i\)</span> 中最小的是 <span
class="math inline">\(m_1\)</span>。由于 <span
class="math inline">\(I_1=(p^{m_1})\)</span>，所以 <span
class="math inline">\(N\)</span> 中必然存在一个元素 <span
class="math inline">\(p^{m_1}e_1\)</span>，其 <span
class="math inline">\(f_1\)</span> 分量为 <span
class="math inline">\(p^{m_1}\)</span>，并且 <span
class="math inline">\(p^{m_1}\)</span> 能够整除其它 <span
class="math inline">\(f_i\)</span> 分量： <span
class="math display">\[p^{m_1}e_1=p^{m_1}f_1+\sum_{i=2}^nr_i&#39;p^{m_i}f_i.\]</span><br />
再考虑
<center>
<p><span class="math inline">\(N&#39;:=Rp^{m_1}e_1+(M_1\cap
N),\quad\)</span>其中<span
class="math inline">\(\;\;M_1:=\displaystyle\sum_{i=2}^nRf_i=\bigoplus_{i=2}^nRf_i.\)</span></p>
</center>
<p>由于 <span class="math inline">\(p^{m_1}e_1\in N\)</span> 而 <span
class="math inline">\(N\)</span> 是子模所以 <span
class="math inline">\(Rp^{m_1}e_1\subset N\)</span>。考虑到 <span
class="math inline">\((M_1\cap N)\subset N\)</span>。因此 <span
class="math inline">\(N&#39;\subset N\)</span>。<br />
从 <span class="math inline">\(N\)</span> 中任取一个元素 <span
class="math inline">\(x\)</span>，假设 <span
class="math inline">\(x\)</span> 的 <span
class="math inline">\(u_1\)</span> 分量为 <span
class="math inline">\(a_1p^{m_1}\)</span>。那么 <span
class="math inline">\(x-a_1p^{m_1}e_1\)</span> 将不会有 <span
class="math inline">\(f_1\)</span> 分量，因此 <span
class="math inline">\(x-a_1p^{m_1}e_1\in (M_1\cap N)\)</span>。显然
<span class="math inline">\(a_1p^{m_1}e_1\in Rp^{m_1}e_1\)</span>，所以
<span class="math inline">\(N\)</span> 中的任两个元素都可写为 <span
class="math inline">\(Rp^{m_1}e_1\)</span> 与 <span
class="math inline">\((M_1\cap N)\)</span> 中元素的和，因此 <span
class="math inline">\(N\subset N&#39;\)</span>。<br />
这样一来，我们证明了 <span class="math inline">\(N=N&#39;\)</span>，即
<span class="math inline">\(N=Rp^{m_1}e_1+(M_1\cap N)\)</span>。考虑到
<span class="math inline">\((M_1\cap N)\)</span> 中的元素除了 <span
class="math inline">\(0\)</span> 以外不会有 <span
class="math inline">\(u_1\)</span> 分量，而 <span
class="math inline">\(Rp^{m_1}e_1\)</span> 只有 <span
class="math inline">\(0\)</span> 没有 <span
class="math inline">\(u_1\)</span> 分量，因此 <span
class="math inline">\(Rp^{m_1}e_1\cap(M_1\cap
N)=\{0\}\)</span>。至此我们证明了 <span
class="math inline">\(N=Rp^{m_1}e_1\oplus(M_1\cap N)\)</span>。</p>
<p>实际上，<span class="math inline">\(M_1\cap N\)</span> 也是子模。如果
<span class="math inline">\(M_1\cap N\)</span> 中有 <span
class="math inline">\(f_2\)</span> 分量不为 <span
class="math inline">\(0\)</span> 的矢量 <span
class="math inline">\(p^{m_2}e_2\)</span>，那么我们也可以对它使用以上步骤，将其分解为
<span class="math inline">\(Rp^{m_2}e_2\oplus(M_2\cap N)\)</span>，其中
<span class="math inline">\(M_2:=\sum_{i=3}^nRf_i\)</span>。如果 <span
class="math inline">\(M_1\cap N\)</span> 中的元素全都没有 <span
class="math inline">\(f_2\)</span> 分量——例如 <span
class="math inline">\(N=Rp^{m_1}(f_1+f_2)\)</span>
就是这种情况——那么就依次考虑 <span
class="math inline">\(f_3,f_4,\cdots\)</span>
分量，再进行以上步骤。这样的步骤总会再有限步之后终止，这样就能够证明
<span class="math inline">\(N=Rp^{m_1}e_1\oplus\cdots\oplus
Rp^{m_r}e_r\)</span>。</p>
<p>以上只是一个证明思路，严格的证明可通过数学归纳法完成。</p>

    </div>
</div>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        (2) 的证明
    </div>
    <div class='spoiler-content'>
        <p>step-(1)<span class="math inline">\(\quad\)</span>现在考虑 <span
class="math inline">\(p\)</span> 模 <span
class="math inline">\(M_p\)</span>、它的一系列子模 <span
class="math inline">\(p^kM_p\)</span>、以及子模之间的商模 <span
class="math inline">\(p^kM_p/p^{k+1}M_p\)</span>： <span
class="math display">\[\begin{align*}
M_p=&amp;\bigoplus_{j=1}^{s}Ru_{j},\quad \mathrm{ann}(u_j)=(p^{m_j}),\\
p^kM_p=&amp;\bigoplus_{j=1}^{s}Rp^ku_{j},\quad
p^kM_p/p^{k+1}M_p=\bigoplus_{j=1}^{s}Rp^ku_{j}/Rp^{k+1}u_{j}.
\end{align*}\]</span></p>
<p>不难想象，<span class="math inline">\(p^kM_p/p^{k+1}M_p\)</span> 也是
<span class="math inline">\(p\)</span> 模，并且 <span
class="math inline">\(\mathrm{ann}(p^kM_p/p^{k+1}M_p)=(p)\)</span> 或
<span class="math inline">\((1)=R\)</span>。</p>
<p>证明思路如下：假设 <span
class="math inline">\(\mathrm{ann}(p^kM_p/p^{k+1}M_p)=(p&#39;)\)</span>。从
<span class="math inline">\(p^kM_p/p^{k+1}M_p\)</span> 中任取一个元素
<span class="math inline">\(\overline{p^km}
:=p^km+p^{k+1}M_p\)</span>，显然 <span
class="math inline">\(p\overline{p^km}=p^{k+1}m+p^{k+1}M_p=\bar
0\)</span>，因此 <span class="math inline">\(p^kM_p/p^{k+1}M_p\)</span>
是 <span class="math inline">\(p\)</span> 模。此外，这还意味着 <span
class="math inline">\(p\in(p&#39;)\)</span>，由于 <span
class="math inline">\(p\)</span> 是素元即不可约元，所以 <span
class="math inline">\(p&#39;\)</span> 只能为 <span
class="math inline">\(p\)</span> 或 <span
class="math inline">\(1\)</span>。</p>
<p>同理，<span class="math inline">\(Rp^ku_{j}/Rp^{k+1}u_{j}\)</span>
也是 <span class="math inline">\(p\)</span> 模，并且 <span
class="math inline">\(\mathrm{ann}(Rp^ku_{j}/Rp^{k+1}u_{j})=(p)\)</span>
或 <span class="math inline">\((1)=R\)</span>。</p>
<hr />
<p>step-(2)<span class="math inline">\(\quad\)</span>由于 <span
class="math inline">\(u_j\)</span> 满足：<span
class="math inline">\(p^{m_j}u_j=0\)</span> 且 <span
class="math inline">\(p^{m_j-1}u_j\neq0\)</span>，所以：</p>
<p>只要 <span class="math inline">\(k\geqslant m_j\)</span> 就有 <span
class="math inline">\(Rp^ku_{j}=Rp^{k+1}u_{j}=\{0\}\)</span>，这意味着
<span
class="math inline">\(\mathrm{ann}(Rp^ku_{j}/Rp^{k+1}u_{j})=R\)</span>。</p>
<p>只要 <span class="math inline">\(k&lt;m_j\)</span> 就有 <span
class="math inline">\(Rp^{k+1}u_j\subsetneq Rp^ku_j\)</span>，这意味着
<span
class="math inline">\(Rp^ku_{j}/Rp^{k+1}u_{j}\neq\{0\}\)</span>，因此
<span
class="math inline">\(\mathrm{ann}(Rp^ku_{j}/Rp^{k+1}u_{j})=(p)\)</span>。</p>
<p>对于那些 <span
class="math inline">\(\mathrm{ann}(Rp^ku_{j}/Rp^{k+1}u_{j})=R\)</span>
的 <span class="math inline">\(j\)</span>，可以直接将其忽略掉，因为
<span
class="math inline">\(Rp^ku_{j}/Rp^{k+1}u_{j}=\{0\}\)</span>，不参与直和。剩下的直和因子的个数——即满足
<span
class="math inline">\(\mathrm{ann}(Rp^ku_{j}/Rp^{k+1}u_{j})=(p)\)</span>
的 <span class="math inline">\(j\)</span> 的个数——记为 <span
class="math inline">\(s_k\)</span>。</p>
<p>于是 <span class="math inline">\(s_k\)</span> 就是 <span
class="math inline">\(\{m_j\}\)</span> 中大于 <span
class="math inline">\(k\)</span> 的数的个数。</p>
<hr />
<p>step-(3)<span class="math inline">\(\quad\)</span>不难看出，<span
class="math inline">\(p^{k+1}M_p\)</span> 作为 <span
class="math inline">\(R\)</span>-模 <span
class="math inline">\(p^kM_p\)</span> 的子模，可视为由 <span
class="math inline">\(R\)</span> 的理想 <span
class="math inline">\((p)\)</span> 左乘 <span
class="math inline">\(p^kM_p\)</span> 得到的子模：<span
class="math inline">\(p^{k+1}M_p=(p)p^kM_p\)</span>，这意味着<a
href="#quotient-module-on-quotient-ring">商模 <span
class="math inline">\(p^kM_p/p^{k+1}M_p\)</span> 也可视为商环 <span
class="math inline">\(R/(p)\)</span> 上的模</a>。</p>
<p>而 <span class="math inline">\(R/(p)\)</span> 实际上是域，因此 <span
class="math inline">\(p^kM_p/p^{k+1}M_p\)</span>
构成域上的线性空间，其维数总是固定的，即 <span
class="math inline">\(s_k\)</span> 是唯一确定的。</p>
<p>由于 <span class="math inline">\(s_k\)</span>，即 <span
class="math inline">\(\{m_j\}\)</span> 中大于 <span
class="math inline">\(k\)</span> 的数的个数，是唯一确定的，所以 <span
class="math inline">\(\{m_j\}\)</span> 是唯一的。</p>

    </div>
</div>
<p>这样就得到了初等因子分解。最后证明不变因子分解。</p>
<div id="PID-finite-generated-module-4"
class="unnumbered statement theorem-unnumbered plain">
<p><span class="statement-heading"><span
class="statement-label">定理</span>.</span><span class="statement-spah">
</span><span class="math inline">\(\,\!\)</span> 假设 <span
class="math inline">\(R\)</span> 是 PID，<span
class="math inline">\(M\)</span> 是 <span
class="math inline">\(R\)</span> 上的有限生成模，那么 <span
class="math inline">\(\mathrm{tor}(M)\)</span> 可分解为一系列 <span
class="math inline">\(Rv_i\simeq R/(d_i)\)</span> 的直和，其中 <span
class="math inline">\(\mathrm{ann}(v_i)=(d_i)\)</span>，并且 <span
class="math inline">\(d_i|d_{i+1}\)</span>。</p>
</div>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        证明
    </div>
    <div class='spoiler-content'>
        <p>(引理)<span class="math inline">\(\quad\)</span><span
class="math inline">\(R\)</span> 是 PID，假设 <span
class="math inline">\(M\)</span> 是 <span
class="math inline">\(R\)</span> 上的左模，<span
class="math inline">\(x,y\in M\)</span>，<span
class="math inline">\(\mathrm{ann}(x)=(a)\)</span>，<span
class="math inline">\(\mathrm{ann}(y)=(b)\)</span>，<span
class="math inline">\(a,b\)</span> 互素，那么： <span
class="math display">\[Rx+Ry=Rx\oplus Ry,\quad
\mathrm{ann}(x+y)=(ab).\]</span> 要证 <span
class="math inline">\(Rx+Ry=Rx\oplus Ry\)</span> 只需证 <span
class="math inline">\(Rx\cap Ry=\{0\}\)</span>。由于 <span
class="math inline">\(a,b\)</span> 互素所以存在 <span
class="math inline">\(u,v\)</span> 使得 <span
class="math inline">\(ua+vb=1\)</span>，因此： <span
class="math display">\[Rx\cap Ry=M(a)\cap
M(b)=M(ua+vb)=M(1)=\{0\}.\]</span> 假设 <span
class="math inline">\(\mathrm{ann}(x+y)=(c)\)</span>。由于 <span
class="math inline">\(ab(x+y)=0\)</span>，所以 <span
class="math inline">\(c|ab\)</span>。又因为 <span
class="math inline">\(Rx+Ry=Rx\oplus Ry\)</span>，所以如果 <span
class="math inline">\(c(x+y)=0\)</span>，就意味着 <span
class="math inline">\(cx=0\)</span> 与 <span
class="math inline">\(cy=0\)</span>，因此 <span
class="math inline">\(a|c\)</span>，<span
class="math inline">\(b|c\)</span>，即 <span
class="math inline">\(ab|c\)</span>。这意味着 <span
class="math inline">\(c=ab\)</span>。因此 <span
class="math inline">\(\mathrm{ann}(x+y)=(ab)\)</span>。</p>
<hr />
<p>基于以上引理，我们来证明不变因子分解。</p>
<p>我们对 <span class="math inline">\(\mathrm{tor}(M)\)</span>
做初等因子分解： <span class="math display">\[\mathrm{tor}(M)\simeq
\bigoplus_{i=1}^n M(p_i^{n_i})\simeq \bigoplus_{i=1}^n
\left(\bigoplus_{j=1}^{m_i}Ru_{ij}\right)\simeq \bigoplus_{i=1}^n
\left(\bigoplus_{j=1}^{m_i}R/(p_i^{k_{ij}})\right),\]</span> 其中 <span
class="math inline">\(\mathrm{ann}(u_{ij})=(p_i^{k_{ij}})\)</span>。</p>
<p>现在取 <span class="math inline">\(m=\max\{m_i\}\)</span>，将 <span
class="math inline">\(u_{i1}\sim u_{im_i}\)</span> 按它们的 <span
class="math inline">\(k_{ij}\)</span> 从小到大排序，并在 <span
class="math inline">\(u_{i1}\)</span> 前面补上 <span
class="math inline">\(0\)</span> 凑满 <span
class="math inline">\(m\)</span> 个，最后得到的序列记为 <span
class="math inline">\(u_{i1}&#39;\sim u_{im}&#39;\)</span>，补充的 <span
class="math inline">\(u_{ij}=0\)</span> 对应的 <span
class="math inline">\(k_{i,j}\)</span> 也设置为 <span
class="math inline">\(0\)</span>。</p>
<p>然后定义： <span
class="math display">\[v_j=\sum_{i=1}^nu_{ij}.\]</span> 根据引理，有：
<span class="math display">\[Rv_j=\bigoplus_{i=1}^nRu_{ij},\quad
\mathrm{ann}(v_j)=\left(\prod_ip_i^{k_{ij}}\right):=(d_j).\]</span> 由于
<span class="math inline">\(u_{i1}\sim u_{im}\)</span> 之间已经按照
<span class="math inline">\(k_{ij}\)</span> 从小到大排好序了，不难验证
<span class="math inline">\(d_j|d_{j+1}\)</span>。</p>

    </div>
</div>
<p>最后，关于不变因子的计算方法，有如下定理：</p>
<div id="Calculating-Invariant-Factors" class="statement theorem plain">
<p><span class="statement-heading"><span class="statement-label">定理
27</span>.</span><span class="statement-spah"> </span><span
class="math inline">\(\,\!\)</span> 假设 <span
class="math inline">\(R\)</span> 是 PID，<span
class="math inline">\(M\)</span> 是 <span
class="math inline">\(R\)</span> 上的秩 <span
class="math inline">\(m\)</span> 自由模，<span
class="math inline">\(N\)</span> 是 <span
class="math inline">\(M\)</span> 的子模，那么 <span
class="math inline">\(M\)</span> 中存在一组基 <span
class="math inline">\(e_1\sim e_m\)</span>，使得 <span
class="math inline">\(d_1e_1\sim d_re_r\)</span> 构成 <span
class="math inline">\(N\)</span> 的一组基，并且 <span
class="math inline">\(d_i\)</span> 满足 <span
class="math inline">\(d_i|d_{i+1}\)</span>。<span
class="math inline">\(r\)</span> 是子模 <span
class="math inline">\(N\)</span> 的秩，<span
class="math inline">\(m-r\)</span> 是商模 <span
class="math inline">\(M/N\)</span> 的秩，<span
class="math inline">\(d_i\)</span> 是商模 <span
class="math inline">\(M/N\)</span> 的不变因子。</p>
</div>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        证明与计算方法
    </div>
    <div class='spoiler-content'>
        <p>(引理)<span class="math inline">\(\quad\)</span>假设 <span
class="math inline">\(A=\begin{bmatrix}a&amp;b\\c&amp;d\end{bmatrix}\)</span>，那么存在矩阵
<span class="math inline">\(B,C\)</span> 使得 <span
class="math display">\[AB=\begin{bmatrix}\mathrm{gcd}(a,b)&amp;0\\ *
&amp; *\end{bmatrix},\quad CA=\begin{bmatrix}\mathrm{gcd}(a,c)&amp; *
\\0&amp; * \end{bmatrix}.\]</span></p>
<p>首先考虑 <span class="math inline">\(B\)</span>。在 PID 中，存在
<span class="math inline">\(u,v,a_1,b_1\)</span> 使得 <span
class="math inline">\(ua+vb=\mathrm{gcd}(a,b)\)</span>，并且 <span
class="math inline">\(a=a_1\mathrm{gcd}(a,b)\)</span>，<span
class="math inline">\(b=b_1\mathrm{gcd}(a,b)\)</span>。那么考虑 <span
class="math display">\[B=\begin{bmatrix}u&amp;-b_1\\v&amp;a_1\end{bmatrix}.\]</span>
由于 <span class="math inline">\(\det B=ua_1+vb_1=1\)</span>，所以 <span
class="math inline">\(B^{-1}=\begin{bmatrix}a_1&amp;b_1\\-v&amp;u\end{bmatrix}\)</span>，因而
<span class="math inline">\(B\)</span> 确实是可逆矩阵。然后： <span
class="math display">\[AB=\begin{bmatrix}a&amp;b\\c&amp;d\end{bmatrix}\begin{bmatrix}u&amp;-b_1\\v&amp;a_1\end{bmatrix}=\begin{bmatrix}\mathrm{gcd}(a,b)&amp;0\\
* &amp; * \end{bmatrix}.\]</span> <span class="math inline">\(C\)</span>
同理。</p>
<hr />
<p>先为 <span class="math inline">\(M\)</span> 选一组基 <span
class="math inline">\(u_1\sim u_n\)</span>，再为 <span
class="math inline">\(N\)</span> 选一组基 <span
class="math inline">\(f_1\sim f_r\)</span>，它在 <span
class="math inline">\(u_1\sim u_n\)</span> 下的表示矩阵为 <span
class="math inline">\(n\)</span> 行 <span
class="math inline">\(r\)</span> 列矩阵 <span
class="math inline">\(A\)</span>，其矩阵元为 <span
class="math inline">\(R\)</span> 中的元素： <span
class="math display">\[(f_1,f_2,\cdots,f_r)=(u_1,u_2,\cdots,u_n)A.\]</span>
在 <span class="math inline">\(M\)</span> 中做坐标变换相当于给 <span
class="math inline">\(A\)</span> 左乘一个可逆矩阵，在 <span
class="math inline">\(N\)</span> 中做坐标变换相当于给 <span
class="math inline">\(A\)</span> 右乘一个可逆矩阵（的逆）。</p>
<p>对矩阵做一次初等行变换相当于左乘一个可逆的初等矩阵，对矩阵做一次初等列变换相当于右乘一个可逆的初等矩阵。初等行列变换包括：交换
<span class="math inline">\(A\)</span> 的两行或两列，为 <span
class="math inline">\(A\)</span> 中的一行或一列乘以 <span
class="math inline">\(R\)</span> 中的可逆元，以及将 <span
class="math inline">\(A\)</span> 中的一行或一列乘以 <span
class="math inline">\(R\)</span>
中的元素加到另一行或另一列上。前两个操作给出可逆矩阵比较显然，最后一个操作中：
<span
class="math display">\[\begin{bmatrix}1&amp;a\\0&amp;1\end{bmatrix}\begin{bmatrix}1&amp;-a\\0&amp;1\end{bmatrix}=\begin{bmatrix}1&amp;0\\0&amp;1\end{bmatrix},\quad
\begin{bmatrix}1&amp;0\\a&amp;1\end{bmatrix}\begin{bmatrix}1&amp;0\\-a&amp;1\end{bmatrix}=\begin{bmatrix}1&amp;0\\0&amp;1\end{bmatrix}.\]</span></p>
<p>现在，对于矩阵 <span
class="math inline">\(A\)</span>，如果能够通过一系列初等行列变换使其变为
<span class="math display">\[\begin{bmatrix}
d_1&amp;&amp;\\
&amp;d_2&amp;&amp;\\
&amp;&amp;\ddots&amp;\\
&amp;&amp;&amp;d_r\\
\\
\\
\end{bmatrix},\qquad
d_1|d_2,\;\;d_2|d_3,\;\;\cdots,\;\;d_{r-1}|d_r,\]</span> 的形式，其中
<span class="math inline">\(d_i|d_{i+1}\)</span>，就能证明这一定理。</p>
<p>以下算法可以将 <span class="math inline">\(A\)</span>
变为以上形式。<br />
1. 利用引理中的办法以及各种初等行列变换，将 <span
class="math inline">\(A\)</span> 变换为 <span
class="math inline">\(\begin{bmatrix}d_1&amp;0_{1\times(r-1)}\\0_{(n-1)\times
1}&amp;A&#39;_{(n-1)\times(r-1)}\end{bmatrix}\)</span> 的形式。 2. 如果
<span class="math inline">\(A&#39;\)</span> 中的每一个矩阵元都能被 <span
class="math inline">\(d_1\)</span> 整除，那么对 <span
class="math inline">\(A&#39;\)</span> 执行步骤 1. 3. 如果 <span
class="math inline">\(A&#39;\)</span> 中的存在一个矩阵元不能被 <span
class="math inline">\(d_1\)</span>
整除，那么将这一元素所在的行加到第一行，或者将这一元素所在的列加到第一列，然后回到步骤
1. 4. 重复以上步骤，直到得到想要的形式。</p>
<p>对于 PID <span class="math inline">\(R\)</span> 中的元素 <span
class="math inline">\(x\)</span>，我们可以定义一个 <span
class="math inline">\(l(x)\)</span>：如果 <span
class="math inline">\(x=p_1^{n_1}\cdots p_k^{n_k}\)</span>
是因子分解，那么 <span
class="math inline">\(l(x)=n_1+\cdots+n_k\)</span>。显然 <span
class="math inline">\(l(x)\geqslant0\)</span>。<br />
在以上算法的步骤 1 中，每一次使用引理都会让 <span
class="math inline">\(l(x)\)</span> 下降，而 <span
class="math inline">\(l(x)\)</span>
有下界，因此以上算法不会陷入死循环。考虑到 <span
class="math inline">\(A\)</span>
的行列都是有限的，所以以上算法总是能在有限步之后中止。</p>
<p>完成这一算法之后，就能得到不变因子组。</p>

    </div>
</div>
<h2
id="结构定理的应用有限生成交换群的结构">结构定理的应用：有限生成交换群的结构</h2>
<p>不难看出，交换群 <span class="math inline">\(G\)</span> 可以构成整环
<span class="math inline">\(\mathbb Z\)</span>
上的模：加法就是交换群的群运算，整环 <span class="math inline">\(\mathbb
Z\)</span> 中的元素 <span class="math inline">\(n\)</span>
在交换群上的作用就是将 <span class="math inline">\(n\)</span>
个元素相加。由于 <span class="math inline">\(\mathbb Z\)</span>
是主理想整环，如果 <span class="math inline">\(G\)</span>
是有限生成的群，那么 <span class="math inline">\(G\)</span>
将有如下两种分解：</p>
<div id="finite-generated-Abel-group" class="statement theorem plain">
<p><span class="statement-heading"><span class="statement-label">定理
28</span>.</span><span class="statement-spah"> </span><span
class="math inline">\(\,\!\)</span> 有限生成交换群 <span
class="math inline">\(G\)</span> 的结构：<br />
(1)<span
class="math inline">\(\quad\)</span>不变因子分解：存在一系列满足 <span
class="math inline">\(d_i|d_{i+1}\)</span> 的 <span
class="math inline">\(\{d_i\}\)</span>，使得： <span
class="math display">\[G\simeq \left(\bigoplus_{i=1}^n\mathbb
Z_{d_i}\right)\oplus\left(\bigoplus_{j=1}^r\mathbb Z\right).\]</span>
(2)<span
class="math inline">\(\quad\)</span>初等因子分解：存在一系列素数 <span
class="math inline">\(p_i\)</span> 与正整数 <span
class="math inline">\(k_{ij}\)</span>，使得： <span
class="math display">\[G\simeq
\left(\bigoplus_{i=1}^n\bigoplus_{j=1}^{s_i}\mathbb
Z_{d_{ij}}\right)\oplus\left(\bigoplus_{j=1}^r\mathbb Z\right),\quad
d_{ij}=p_i^{k_{ij}}.\]</span> (3)<span
class="math inline">\(\quad\)</span>这里的 <span
class="math inline">\(r\)</span> 称为交换群的秩或 Betti 数，<span
class="math inline">\(d_i\)</span> 称为不变因子或扭系数，<span
class="math inline">\(p_i^{k_{ij}}\)</span> 称为初等因子。</p>
</div>
<h2 id="结构定理的应用矩阵的-jordan-标准型">结构定理的应用：矩阵的
Jordan 标准型</h2>
<p>假设 <span class="math inline">\(A\)</span> 是 <span
class="math inline">\(\mathbb C\)</span> 上有限维线性空间 <span
class="math inline">\(V\)</span> 上的线性变换，其矩阵也记为 <span
class="math inline">\(A\)</span>。那么 <span
class="math inline">\(V\)</span> 也可视为多项式环 <span
class="math inline">\(\mathbb C[x]\)</span> 的左模，环作用为： <span
class="math display">\[fv:=f(A)v,\quad f\in \mathbb C[x],\quad v\in
V.\]</span> <span class="math inline">\(V\)</span>
是有限维的因而是有限生成的，<span class="math inline">\(\mathbb
C[x]\)</span> 是主理想整环，根据结构定理，可对 <span
class="math inline">\(V\)</span> 做初等因子分解与不变因子分解。</p>
<p>Cayley-Hamilton 定理告诉我们：</p>
<div id="Cayley-Hamilton" class="statement theorem plain">
<p><span class="statement-heading"><span class="statement-label">定理
29</span>.</span><span class="statement-spah"> </span><span
class="math inline">\(\,\!\)</span><strong>（Cayley-Hamilton
定理）</strong><br />
<span class="math inline">\(A\)</span> 是矩阵，<span
class="math inline">\(f(\lambda):=\det(\lambda I-A)\)</span> 是 <span
class="math inline">\(A\)</span> 的特征多项式，那么 <span
class="math inline">\(f(A)=0\)</span>。</p>
</div>
<p>因此 <span class="math inline">\(V\)</span> 是个扭模，因为 <span
class="math inline">\(f(A)V=0\)</span>。满足 <span
class="math inline">\(m(A)V=0\)</span> 的次数最低的首一（最高次项系数为
<span class="math inline">\(1\)</span>）多项式 <span
class="math inline">\(m(x)\)</span> 称为 <span
class="math inline">\(A\)</span>
的<strong>最小多项式</strong>。不难想象，如果 <span
class="math display">\[f(x)=(x-\lambda_1)^{n_1}\cdots(x-\lambda_k)^{n_k},\]</span>
那么： <span
class="math display">\[m(x)=(x-\lambda_1)^{m_1}\cdots(x-\lambda_k)^{m_k},\quad
m_i\leqslant n_i.\]</span> 不难想象，<span
class="math inline">\(\mathrm{ann}(V)=(m(x))\)</span>。</p>
<p>注意到 <span class="math inline">\((x-\lambda_i)\)</span> 是 <span
class="math inline">\(\mathbb C[x]\)</span>
中的不可约多项式，所以我们有准素分解与初等因子分解：</p>
<div id="Primary-Decomposition-of-matrix"
class="statement theorem plain">
<p><span class="statement-heading"><span class="statement-label">定理
30</span>.</span><span class="statement-spah"> </span><span
class="math inline">\(\,\!\)</span><strong>（准素分解与初等因子分解）</strong>
如果 <span class="math inline">\(A\)</span> 是线性空间 <span
class="math inline">\(V\)</span> 上的矩阵，<span
class="math inline">\(A\)</span> 的最小多项式为 <span
class="math inline">\(m(x)=(x-\lambda_1)^{m_1}\cdots(x-\lambda_k)^{m_k}\)</span>，那么：<br />
(1)<span class="math inline">\(\quad\)</span>准素分解： <span
class="math display">\[V=V_1\oplus\cdots\oplus V_k,\quad
V_i=\mathrm{ker}[(A-\lambda_i)^{m_i}].\]</span> (2)<span
class="math inline">\(\quad\)</span>初等因子分解： <span
class="math display">\[V=\bigoplus_{i=1}^k\bigoplus_{j=1}^{l_s}V_{ij},\quad
(A-\lambda_i)^{r_{ij}}V_{ij}=\{0\}.\]</span></p>
</div>
<p>在初等因子分解中，可以为 <span class="math inline">\(V_{ij}\)</span>
找一组基： <span class="math display">\[x_1,\quad
x_2:=(A-\lambda_iI)x,\quad \cdots,\quad
x_{r_{ij}}:=(A-\lambda_iI)^{r_{ij}-1}x.\]</span> 那么不难看出： <span
class="math display">\[\begin{align*}
Ax_t=(A-\lambda_iI)x_t+\lambda_ix_t=x_{t+1}+\lambda_ix_t.
\end{align*}\]</span> 其中 <span
class="math inline">\(x_{r_{ij}+1}=(A-\lambda_iI)x_{r_{ij}}=0\)</span>。因此，在这组基下，<span
class="math inline">\(A|_{V_{ij}}\)</span> 的矩阵表示为： <span
class="math display">\[\begin{bmatrix}
\lambda_i&amp;1&amp;&amp;&amp;\\
&amp;\lambda_i&amp;1&amp;&amp;\\
&amp;&amp;\ddots&amp;\ddots&amp;\\
&amp;&amp;&amp;\lambda_i&amp;1\\
&amp;&amp;&amp;&amp;\lambda_i\\
\end{bmatrix}\]</span> 这就是构建 Jordan 标准型的 Jordan 块。</p>
<p>因此，要找出 Jordan
标准型只需要找出初等因子，而初等因子可通过不变因子得到。根据定理 <a
href="#Calculating-Invariant-Factors" title="27">27</a>，假设 <span
class="math inline">\(A\)</span> 是 <span
class="math inline">\(n\)</span> 维线性空间 <span
class="math inline">\(V\)</span> 上的矩阵、<span
class="math inline">\(M\)</span> 是多项式环 <span
class="math inline">\(F[x]\)</span> 上的 <span
class="math inline">\(n\)</span> 秩自由模，那么只需要找到 <span
class="math inline">\(M\)</span> 的一个子模 <span
class="math inline">\(N\)</span> 使其满足 <span
class="math inline">\(M/N\simeq V\)</span>，就能根据定理 <a
href="#Calculating-Invariant-Factors" title="27">27</a> 算出 <span
class="math inline">\(V\)</span> 的不变因子。由于 <span
class="math inline">\(F[x]\)</span> 在 <span
class="math inline">\(V\)</span> 上的环作用为：<span
class="math inline">\(f(x)v=f(A)v\)</span>——其中 <span
class="math inline">\(v\in V\)</span> 以及 <span
class="math inline">\(f(x)\in F[x]\)</span>——所以 <span
class="math inline">\(N\)</span> 应该由 <span
class="math display">\[(f_1,\cdots,f_n)=x\cdot(e_1,\cdots,e_n)-(e_1,\cdots,e_n)A\]</span>
生成，这里的 <span class="math inline">\(e_1\sim e_n\)</span> 是 <span
class="math inline">\(M\)</span> 的一组基。因此，只需要对矩阵 <span
class="math inline">\((xI-A)\)</span> 使用定理 <a
href="#Calculating-Invariant-Factors" title="27">27</a>
中的算法就能得到不变因子。</p>
<hr />
<h1 id="半单环的结构">半单环的结构</h1>
<p>左单环就是除了 <span class="math inline">\(\{0\}\)</span>
与自己之外没有其他左理想的环，它可视为自己的左模，并且是自己的左单模。比单模复杂一些的是半单模：</p>
<div id="semi-simple-module" class="statement definition plain">
<p><span class="statement-heading"><span class="statement-label">定义
25</span>.</span><span class="statement-spah"> </span><span
class="math inline">\(\,\!\)</span><strong>（半单模与半单环）</strong><br />
(1)<span
class="math inline">\(\quad\)</span>如果一个模同构于有限个单模的直和，就说这个模是<strong>半单（semi-simple）模</strong>。<br />
(2)<span
class="math inline">\(\quad\)</span>作为自己的左模是半单模的幺环就是左<strong>半单环</strong>。</p>
</div>
<p>将幺环视为自己的左模时，单模就是极小左理想，所以半单环是非常简单的环。以下讨论哪些幺环是半单环，半单环有何性质。</p>
<h2 id="幂等元与幂零元">幂等元与幂零元</h2>
<div id="idempotent" class="statement definition plain">
<p><span class="statement-heading"><span class="statement-label">定义
26</span>.</span><span class="statement-spah"> </span><span
class="math inline">\(\,\!\)</span><strong>（幂等元）</strong><br />
假设 <span class="math inline">\(a\)</span> 是幺环 <span
class="math inline">\(R\)</span> 中的元素。<br />
(1)<span class="math inline">\(\quad\)</span>如果 <span
class="math inline">\(a^2=a\)</span>，就说 <span
class="math inline">\(a\)</span>
是一个<strong>幂等（idempotent）元</strong>。<br />
(2)<span class="math inline">\(\quad\)</span>如果两个幂等元 <span
class="math inline">\(a,b\)</span> 满足 <span
class="math inline">\(ab=ba=0\)</span>，就说它们互相正交。<br />
(3)<span
class="math inline">\(\quad\)</span>如果一个幂等元不能写为两个正交幂等元之和，就说这是一个本原幂等元。</p>
</div>
<p>关于幂等元，有如下 Peirce 分解：</p>
<p><span id="Peirce"></p>
<div id="Peirce" class="statement theorem plain">
<p><span class="statement-heading"><span class="statement-label">定理
31</span>.</span><span class="statement-spah"> </span><span
class="math inline">\(\,\!\)</span><strong>（Peirce
分解）</strong><br />
假设 <span class="math inline">\(R\)</span> 是幺环，那么：<br />
(1)<span class="math inline">\(\quad\)</span>如果 <span
class="math inline">\(R\)</span> 中有幂等元 <span
class="math inline">\(e\)</span>，那么 <span
class="math inline">\(R=Re\oplus R(1-e)=eR\oplus (1-e)R\)</span>。<br />
(2)<span class="math inline">\(\quad\)</span>幺环 <span
class="math inline">\(R\)</span> 作为自己的左模可写为左理想 <span
class="math inline">\(I_i\)</span> 的直和 <span
class="math inline">\(_RR=\displaystyle\bigoplus_{i=1}^nI_i\)</span>
当且仅当存在一系列互相正交的幂等元 <span
class="math inline">\(e_i\)</span> 使得 <span
class="math inline">\(1=\sum_{i=1}^ne_i\)</span> 并且 <span
class="math inline">\(I_i=Re_i\)</span>。<br />
(3)<span class="math inline">\(\quad\)</span>幺环 <span
class="math inline">\(R\)</span> 作为自己的右模可写为右理想 <span
class="math inline">\(I_i\)</span> 的直和 <span
class="math inline">\(_RR=\displaystyle\bigoplus_{i=1}^nI_i\)</span>
当且仅当存在一系列互相正交的幂等元 <span
class="math inline">\(e_i\)</span> 使得 <span
class="math inline">\(1=\sum_{i=1}^ne_i\)</span> 并且 <span
class="math inline">\(I_i=e_iR\)</span>。<br />
(4)<span class="math inline">\(\quad\)</span>如果 <span
class="math inline">\(e\)</span> 是幂等元且 <span
class="math inline">\(Re\)</span> 或 <span
class="math inline">\(eR\)</span> 是 <span
class="math inline">\(R\)</span> 的极小理想，那么 <span
class="math inline">\(e\)</span> 一定是本原幂等元。</p>
</div>
<p></span></p>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        证明
    </div>
    <div class='spoiler-content'>
        <p>(1)<span class="math inline">\(\quad\)</span>首先，由于 <span
class="math inline">\(e^2=e\)</span>，所以 <span
class="math inline">\(e(e-1)=(e-1)e=0\)</span>。然后，由于 <span
class="math inline">\(r=re+r(1-e)\)</span>，所以 <span
class="math inline">\(R=Re+R(1-e)\)</span>。最后，如果 <span
class="math inline">\(r_1e=r_2(1-e)\)</span>，那么 <span
class="math inline">\(0=r_2(1-e)e=r_1e^2=r_1e\)</span>，因此 <span
class="math inline">\(Re\cap R(1-e)=\{0\}\)</span>。所以，<span
class="math inline">\(R=Re\oplus R(1-e)\)</span>。同理 <span
class="math inline">\(R=eR\oplus (1-e)R\)</span>。</p>
<p>(2, <span class="math inline">\(\Leftarrow\)</span>)<span
class="math inline">\(\quad\)</span>不难证明 <span
class="math inline">\(_RR=\sum_iRe_i\)</span>，因此只证明 <span
class="math inline">\(I_i\cap\left(\sum_{j\neq
i}I_j\right)=\{0\}\)</span>。假设 <span
class="math display">\[r_ie_i=\sum_{j\neq i}r_je_j.\]</span> 两边同乘
<span class="math inline">\(e_j\)</span>（其中 <span
class="math inline">\(j\neq i\)</span>），就能得到 <span
class="math inline">\(r_je_j=0\)</span>，这意味着 <span
class="math inline">\(r_ie_i=0+\cdots+0=0\)</span>，因此 <span
class="math inline">\(I_i\cap\left(\sum_{j\neq
i}I_j\right)=\{0\}\)</span>。</p>
<p>(2, <span class="math inline">\(\Rightarrow\)</span>)<span
class="math inline">\(\quad\)</span>由于 <span
class="math inline">\(_RR=\displaystyle\bigoplus_{i=1}^nI_i\)</span>，所以
<span class="math inline">\(1\)</span> 可以唯一地写为 <span
class="math inline">\(1=a_1+\cdots+a_n\)</span>，其中 <span
class="math inline">\(a_i\in I_i\)</span>。由于 <span
class="math display">\[a_i=a_i\cdot 1=a_ia_1+\cdots+a_i^2+\cdots
a_ia_n,\]</span> 所以 <span class="math inline">\(a_i,a_i^2\in
I_i\)</span>，这意味着 <span class="math inline">\(a_i-a_i^2\in
I_i\)</span>。但同时 <span class="math inline">\(a_i-a_i^2\in
\sum_{j\neq i}I_j\)</span>，由于 <span class="math inline">\(R\)</span>
是 <span class="math inline">\(I_i\)</span> 的直和，所以 <span
class="math inline">\(a_i-a_i^2=0\)</span>，因而 <span
class="math inline">\(a_i\)</span> 都是幂等元。<br />
由于 <span
class="math inline">\(0=a_ia_1+\cdots+a_ia_{i-1}+0+a_ia_{i+1}+\cdots
a_ia_n\)</span>，而 <span class="math inline">\(R\)</span> 中 <span
class="math inline">\(0\)</span> 的表示是唯一的，所以 <span
class="math inline">\(i\neq j\)</span> 时只能有 <span
class="math inline">\(a_ia_j=0\)</span>，因此 <span
class="math inline">\(a_i\)</span> 之间是正交幂等元。<br />
从 <span class="math inline">\(I_i\)</span> 中任取一个元素 <span
class="math inline">\(b_i\)</span>，由于 <span
class="math display">\[b_i=b_i\cdot
1=b_ia_1+\cdots+b_ia_i+\cdots+b_ia_n,\quad b_i\in I_i,\quad b_ia_j\in
I_j,\]</span> 所以 <span class="math inline">\(j\neq i\)</span> 时 <span
class="math inline">\(b_ia_j=0\)</span>，因此 <span
class="math inline">\(b_i=b_ia_i\)</span>。由于 <span
class="math inline">\(b_i\in I_i\subset R\)</span>，所以 <span
class="math inline">\(I_i\subset Ra_i\)</span>。由于 <span
class="math inline">\(Ra_i\subset I_i\)</span> 因为 <span
class="math inline">\(a\in I_i\)</span>，所以 <span
class="math inline">\(I_i=Ra_i\)</span>。</p>
<p>(3)<span class="math inline">\(\quad\)</span>同理。</p>
<p>(4)<span class="math inline">\(\quad\)</span>如果 <span
class="math inline">\(e\)</span>
不是本原幂等元，那么就存在两个互相正交的幂等元 <span
class="math inline">\(u,v\)</span> 使得 <span
class="math inline">\(e=u+v\)</span>。考虑 <span
class="math inline">\(Ru\)</span>，它显然是一个理想，并且 <span
class="math inline">\(Ru\subsetneq Re\)</span>，这与 <span
class="math inline">\(Re\)</span> 是极小理想，即 <span
class="math inline">\(Re\)</span> 除了 <span
class="math inline">\(\{0\}\)</span> 以外没有其他理想相矛盾。</p>

    </div>
</div>
<p>与幂等元在某种程度上对立的是幂零元：</p>
<div id="nilpotent_idea" class="statement definition plain">
<p><span class="statement-heading"><span class="statement-label">定义
27</span>.</span><span class="statement-spah"> </span><span
class="math inline">\(\,\!\)</span><strong>（幂零元与幂零理想）</strong><br />
(1)<span class="math inline">\(\quad\)</span>假设 <span
class="math inline">\(a\)</span> 是幺环 <span
class="math inline">\(R\)</span> 中的元素，如果存在一个 <span
class="math inline">\(n\)</span> 使得 <span
class="math inline">\(a^n=0\)</span> 就说 <span
class="math inline">\(a\)</span> 是一个<strong>幂零元（nilpotent
element）</strong>。<br />
(2)<span class="math inline">\(\quad\)</span>假设 <span
class="math inline">\(N\)</span> 是幺环 <span
class="math inline">\(R\)</span> 的理想，如果存在一个 <span
class="math inline">\(n\)</span> 使得 <span
class="math inline">\(N^n=\{0\}\)</span>，即 <span
class="math inline">\(N\)</span> 中任意 <span
class="math inline">\(n\)</span> 个元素的乘积一定为 <span
class="math inline">\(0\)</span>，就说 <span
class="math inline">\(N\)</span> 是幺环 <span
class="math inline">\(R\)</span> 的<strong>幂零理想（nilpotent
idea）</strong>。<br />
(3)<span class="math inline">\(\quad\)</span>假设 <span
class="math inline">\(N\)</span> 是幺环 <span
class="math inline">\(R\)</span> 的理想，如果 <span
class="math inline">\(N\)</span> 中每一个元素都是幂零元，就说 <span
class="math inline">\(N\)</span> 是一个<strong>诣零理想（nil
idea）</strong>。不难看出，幂零理想都是诣零理想。</p>
</div>
<p>诣零理想不是幂零理想的例子是：</p>
<div id="nil_idea_nilpotent_idea"
class="statement example definition unnumbered">
<p><span class="statement-heading"><span
class="statement-label">例子</span>：</span><span
class="statement-spah"> </span><span class="math inline">\(\,\!\)</span>
考虑交换环 <span class="math inline">\(\mathbb
Z[x_1,x_2,x_3,\cdots]/(x_1^2,x_2^3,x_3^4,\cdots)\)</span>，注意它不包括无穷级数，以及
<span class="math inline">\((\bar x_k)^{k+1}=\bar 0\)</span>。然后考虑
<span class="math inline">\(\bar x_1,\bar x_2,\bar x_3,\cdots\)</span>
生成的理想 <span
class="math inline">\(I\)</span>。它是诣零的，但不是幂零的。</p>
</div>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        证明
    </div>
    <div class='spoiler-content'>
        <p><span class="math inline">\(I\)</span> 中的每一个元素都是幂零的：从
<span class="math inline">\(I\)</span> 中取一个元素 <span
class="math inline">\(r\)</span>，<span
class="math inline">\(r=\sum_{i=1}^mz_i(\bar
x_{a_i})^{b_i}\)</span>。假设 <span class="math inline">\(a_i\)</span>
中最大的是 <span
class="math inline">\(n\)</span>，那么根据二项式展开不难想象 <span
class="math inline">\(r^{m(n+1)}=\bar 0\)</span>，因为每一个 <span
class="math inline">\((\bar x_{a_i})^{b_i}\)</span> 分到的指数都不会低于
<span class="math inline">\((n+1)\)</span>。</p>
<p>但是 <span class="math inline">\(I\)</span> 不是幂零理想：如果 <span
class="math inline">\(I^n=\{0\}\)</span>，那么考虑 <span
class="math inline">\(\bar x_n\)</span> 就能发现 <span
class="math inline">\((\bar x_n)^n\neq0\)</span>。</p>

    </div>
</div>
<h2 id="jacobson-根">Jacobson 根</h2>
<p>人们把环中的一些性质不太好的元素构成的双边理想称为<strong>根（radical）</strong>。一般而言，如果
<span class="math inline">\(I\)</span> 是环 <span
class="math inline">\(R\)</span> 的根，那么 <span
class="math inline">\(R/I\)</span>
往往就不会再有这些不好的性质，这就是人们引入根这一概念的原因。常见的根包括
Jacobson 根与交换环的幂零根等。</p>
<div id="Jacobson" class="statement definition plain">
<p><span class="statement-heading"><span class="statement-label">定义
28</span>.</span><span class="statement-spah"> </span><span
class="math inline">\(\,\!\)</span><strong>（Jacobson
根）</strong><br />
(1)<span class="math inline">\(\quad\)</span>幺环 <span
class="math inline">\(R\)</span> 中所有极大左理想的交集称为 <span
class="math inline">\(R\)</span> 的 <strong>Jacobson
根（radical）</strong>，记为 <span
class="math inline">\(J(R)\)</span>。<br />
(2)<span class="math inline">\(\quad\)</span>如果 <span
class="math inline">\(J(R)=\{0\}\)</span>，就说 <span
class="math inline">\(R\)</span> 是 Jacobson 半单的。</p>
</div>
<p>Jacobson 根还有几个等价定义：</p>
<p><span id="Jacobson-equivalence"></p>
<div id="Jacobson-equivalence" class="statement theorem plain">
<p><span class="statement-heading"><span class="statement-label">定理
32</span>.</span><span class="statement-spah"> </span><span
class="math inline">\(\,\!\)</span> 假设 <span
class="math inline">\(R\)</span> 是幺环，那么 <span
class="math inline">\(J(R)=J_1(R)=J_2(R)=J_3(R)=J_4(R)\)</span>，其中：<br />
(1)<span class="math inline">\(\quad\)</span><span
class="math inline">\(J_1(R)\)</span> 是幺环 <span
class="math inline">\(R\)</span> 中所有极大右理想的交集。<br />
(2)<span class="math inline">\(\quad\)</span><span
class="math inline">\(J_2(R)=\{x\in R:\quad \forall a\in
R,\;1-ax\)</span> 有乘法逆元 <span
class="math inline">\(\}\)</span>。<br />
(3)<span class="math inline">\(\quad\)</span><span
class="math inline">\(J_3(R)=\{x\in R:\quad \forall a\in
R,\;1-xa\)</span> 有乘法逆元 <span
class="math inline">\(\}\)</span>。<br />
(4)<span class="math inline">\(\quad\)</span><span
class="math inline">\(J_4(R)=\{x\in R:\quad \forall a,b\in
R,\;1+axb\)</span> 有乘法逆元 <span
class="math inline">\(\}\)</span>。</p>
</div>
<p></span></p>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        证明
    </div>
    <div class='spoiler-content'>
        <p>先证明 (2)</p>
<p>(2)<span class="math inline">\(\quad\)</span>首先证明 <span
class="math inline">\(J_2(R)=J_2&#39;(R)\)</span>，其中 <span
class="math inline">\(J_2&#39;(R)=\{x\in R:\quad \forall a\in
R,\;1-ax\)</span> 有乘法左逆元 <span
class="math inline">\(\}\)</span>。</p>
<p>显然 <span class="math inline">\(J_2(R)\subset
J_2&#39;(R)\)</span>。从 <span
class="math inline">\(J_2&#39;(R)\)</span> 中任取一个 <span
class="math inline">\(x\)</span>，从 <span
class="math inline">\(R\)</span> 中任取一个 <span
class="math inline">\(a\)</span>，那么存在 <span
class="math inline">\(u\)</span> 使得 <span
class="math inline">\(u(1-ax)=1\)</span>。这意味着 <span
class="math inline">\(u=1+uax\)</span>，不难发现 <span
class="math inline">\(u\in J_2&#39;(R)\)</span>，因此 <span
class="math inline">\(u\)</span> 也有左逆元，假设为 <span
class="math inline">\(v\)</span>。考虑到 <span
class="math inline">\(vu(1-ax)=(1-ax)=v\)</span>，因此 <span
class="math inline">\(u\)</span> 还是 <span
class="math inline">\((1-ax)\)</span> 的右逆元，因此 <span
class="math inline">\((1-ax)\)</span> 有乘法逆元。这意味着 <span
class="math inline">\(J_2&#39;(R)\subset J_2(R)\)</span>。因此 <span
class="math inline">\(J_2(R)=J_2&#39;(R)\)</span>。</p>
<p>先证 <span class="math inline">\(J(R)\subset J_2&#39;(R)\)</span>。从
<span class="math inline">\(J(R)\)</span> 中任取一个 <span
class="math inline">\(x\)</span>。假设存在 <span
class="math inline">\(a\in R\)</span> 使得 <span
class="math inline">\(1-ax\)</span> 没有左逆元，那么 <span
class="math inline">\(R(1-ax)\)</span> 将不会包括 <span
class="math inline">\(1\)</span>，因此 <span
class="math inline">\(R(1-ax)\)</span> 是一个不为 <span
class="math inline">\(\{0\}\)</span> 与 <span
class="math inline">\(R\)</span> 的左理想。假设 <span
class="math inline">\(R(1-ax)\)</span> 被包含在极大左理想 <span
class="math inline">\(I\)</span> 中。考虑到 <span
class="math inline">\(x\in J(R)\subset I\)</span>，所以 <span
class="math inline">\(Rax\subset I\)</span>，这意味着 <span
class="math inline">\(R=R(1-ax)+Rax\subset I\)</span>，这与 <span
class="math inline">\(I\)</span> 是极大左理想矛盾。因此 <span
class="math inline">\(J(R)\subset J_2&#39;(R)\)</span>。</p>
<p>再证 <span class="math inline">\(J_2&#39;(R)\subset J(R)\)</span>。从
<span class="math inline">\(J_2&#39;(R)\)</span> 中任取一个 <span
class="math inline">\(x\)</span>。假设 <span
class="math inline">\(x\notin J(R)\)</span>，那么存在一个极大理想 <span
class="math inline">\(I\)</span> 使得 <span
class="math inline">\(x\notin I\)</span>。此时，因为 <span
class="math inline">\(Rx+I\)</span> 也是左理想且包含了 <span
class="math inline">\(I\)</span>，所以 <span
class="math inline">\(Rx+I=R\)</span>，这意味着存在 <span
class="math inline">\(a\in R\)</span> 和 <span
class="math inline">\(u\in I\)</span> 使得 <span
class="math inline">\(ax+u=1\)</span>，即 <span
class="math inline">\(u=1-ax\in I\)</span>。<span
class="math inline">\(u\)</span> 不能有逆元否则 <span
class="math inline">\(I=R\)</span>，这与 <span
class="math inline">\(x\in J&#39;_2(R)\)</span> 矛盾。因此 <span
class="math inline">\(J&#39;_2(R)\subset J(R)\)</span>。</p>
<p>这样就证明了 <span
class="math inline">\(J(R)=J_2&#39;(R)=J_2(R)\)</span>。</p>
<p>(3)<span class="math inline">\(\quad\)</span>与 (2) 一样，可证明
<span class="math inline">\(J_1(R)=J_3(R)\)</span>。</p>
<hr />
<p>(1)<span
class="math inline">\(\quad\)</span>我们在线性代数中学过如下公式： <span
class="math display">\[(1-AB)^{-1}=1+A(I-BA)^{-1}B.\]</span> 证明如下：
<span class="math display">\[\begin{align*}
(1-AB)(1-AB)^{-1}=&amp;\;1+A(1-BA)^{-1}B-AB-ABA(1-BA)^{-1}B\\
=&amp;\;(1-AB)+(1-AB)A(1-BA)^{-1}B\\
=&amp;\;(1-AB)+A(1-BA)(1-BA)^{-1}B\\
=&amp;\;1.
\end{align*}\]</span> 这意味着 <span class="math inline">\(1-xa\)</span>
与 <span class="math inline">\(1-ax\)</span>
要么同时有逆元，要么同时没有，因此 <span
class="math inline">\(J_2(R)=J_3(R)\)</span>，所以 <span
class="math inline">\(J(R)=J_1(R)\)</span>。这也意味着 <span
class="math inline">\(J(R)\)</span> 是双边理想。</p>
<hr />
<p>(4)<span class="math inline">\(\quad\)</span>显然 <span
class="math inline">\(J_4(R)\subset J_2(R)\)</span>，以及 <span
class="math inline">\(J_4(R)\subset J_3(R)\)</span>。现在证明 <span
class="math inline">\(J(R)\subset J_4(R)\)</span>。</p>
<p>从 <span class="math inline">\(J(R)\)</span> 中任取一个 <span
class="math inline">\(x\)</span>，从 <span
class="math inline">\(R\)</span> 中任取两个元素 <span
class="math inline">\(a,b\)</span>，考虑 <span
class="math inline">\(axb\)</span>。由于 <span
class="math inline">\(J(R)\)</span> 是双边理想，所以 <span
class="math inline">\(Rx\subset J(R)\)</span>，因此 <span
class="math inline">\(ax\in J(R)\)</span>，由于 <span
class="math inline">\(J(R)=J_3(R)\)</span>，所以 <span
class="math inline">\(1+axb\)</span> 有逆元，因此 <span
class="math inline">\(x\in J_4(R)\)</span>，从而证明了 <span
class="math inline">\(J(R)\subset J_4(R)\)</span>。</p>

    </div>
</div>
<p>以上定理意味着 <span class="math inline">\(J(R)\)</span>
实际上是一个双边理想。</p>
<p>关于 Jacobson 根还有如下结果：</p>
<div id="Jacobson-theorem" class="statement theorem plain">
<p><span class="statement-heading"><span class="statement-label">定理
33</span>.</span><span class="statement-spah"> </span><span
class="math inline">\(\,\!\)</span> 假设 <span
class="math inline">\(R\)</span> 是幺环，那么：<br />
(1)<span class="math inline">\(\quad\)</span>商环 <span
class="math inline">\(R/J(R)\)</span> 是 Jacobson 半单的，即 <span
class="math inline">\(J(R/J(R))=\{0\}\)</span>。<br />
(2)<span class="math inline">\(\quad\)</span><strong>（Nakayama
引理）</strong> 如果 <span class="math inline">\(M\)</span>
是有限生成的左 <span class="math inline">\(R\)</span>-模，<span
class="math inline">\(J(R)M=M\)</span>，那么 <span
class="math inline">\(M=\{0\}\)</span>。<br />
(3)<span class="math inline">\(\quad\)</span>幺环 <span
class="math inline">\(R\)</span> 的任意一个幂零理想都是 Jacobson
根的子集。<br />
(4)<span class="math inline">\(\quad\)</span>如果幺环 <span
class="math inline">\(R\)</span> 是左 Artin 环，那么 Jacobson
根也是幂零理想。</p>
</div>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        证明
    </div>
    <div class='spoiler-content'>
        <p>(1)<span class="math inline">\(\quad\)</span>商环 <span
class="math inline">\(R/J(R)\)</span> 中的元素是等价类 <span
class="math inline">\(\bar u:=u+J(R)\)</span>。假设 <span
class="math inline">\(\bar u\in J(R/J(R))\)</span>，那么任取一个 <span
class="math inline">\(\bar r\in R/J(R)\)</span> 都有 <span
class="math inline">\(\bar 1-\bar r\bar u\)</span> 可逆。假设 <span
class="math inline">\(\bar v(\bar 1-\bar r\bar u)=\bar
1\)</span>，这意味着 <span
class="math inline">\((v+J(R))(1-ru+J(R))=1+J(R)\)</span>，因此存在一个
<span class="math inline">\(a\in J(R)\)</span> 使得 <span
class="math display">\[v(1-ru)=1-a.\]</span> 由于 <span
class="math inline">\(a\in J(R)\)</span> 因此存在一个 <span
class="math inline">\(w\in R\)</span> 使得 <span
class="math inline">\(w(1-a)=1\)</span>，所以： <span
class="math display">\[wv(1-ru)=1.\]</span> 由于 <span
class="math inline">\(r\)</span> 是任取的，<span
class="math inline">\((1-ru)\)</span> 有逆，因此 <span
class="math inline">\(u\in J(R)\)</span>，即 <span
class="math inline">\(\bar u=\bar 0\)</span>，因此 <span
class="math inline">\(J(R/J(R))=\{0\}\)</span>。</p>
<hr />
<p>(2)<span class="math inline">\(\quad\)</span>假设 <span
class="math inline">\(M\)</span> 可由 <span
class="math inline">\(e_1\sim e_n\)</span> 生成，并且这组生成元是 <span
class="math inline">\(M\)</span> 所有的生成元组中 <span
class="math inline">\(n\)</span> 最小的一个。由于 <span
class="math inline">\(J(R)M=M\)</span>，所以存在一些 <span
class="math inline">\(r_i\in J(R)\)</span> 使得 <span
class="math inline">\(e_1=\sum_{i=1}^nr_ie_i\)</span>。这意味着 <span
class="math display">\[(1-r_1)e_1=\sum_{i=2}^nr_ie_i.\]</span> 由于
<span class="math inline">\(r_1\in J(R)\)</span>，所以 <span
class="math inline">\((1-r_1)\)</span> 有左逆 <span
class="math inline">\(u\)</span>，因此 <span
class="math inline">\(e_1=\sum_{i=2}^nur_ie_i\)</span>，这意味着 <span
class="math inline">\(e_1\)</span> 可由 <span
class="math inline">\(e_2\sim e_n\)</span> 表出，这与 <span
class="math inline">\(e_1\sim e_n\)</span> 是 <span
class="math inline">\(M\)</span> 的生成元组中 <span
class="math inline">\(n\)</span> 最小的一个相矛盾。</p>
<hr />
<p>(3)<span class="math inline">\(\quad\)</span>假设 <span
class="math inline">\(I\)</span> 是幂零的左理想，任取 <span
class="math inline">\(x\in I\)</span>，任取 <span
class="math inline">\(a\in R\)</span>，那么 <span
class="math inline">\(ax\in I\)</span>。由于 <span
class="math inline">\(I\)</span> 是幂零理想，因此存在 <span
class="math inline">\(n\)</span> 使得 <span
class="math inline">\((ax)^n=0\)</span>。由于 <span
class="math display">\[[1+ax+(ax)^2+\cdots+(ax)^{n-1}]\cdot
(1-ax)=1,\]</span> 所以 <span class="math inline">\(1-ax\)</span>
是可逆元。由于 <span class="math inline">\(a\)</span> 是任取的，所以
<span class="math inline">\(x\in J(R)\)</span>，所以 <span
class="math inline">\(I\subset J(R)\)</span>。</p>
<p>同理，任意一个幂零的右理想与双边理想都是 Jacobson 根的子集。</p>
<hr />
<p>(4)<span class="math inline">\(\quad\)</span>将 <span
class="math inline">\(J(R)\)</span> 简记为 <span
class="math inline">\(J\)</span>，考虑理想的降链： <span
class="math display">\[R\supset J\supset J^2\supset
J^3\supset\cdots.\]</span> 由于 <span class="math inline">\(R\)</span>
是左 Artin 环，所以总存在 <span class="math inline">\(m\)</span> 使得
<span class="math inline">\(J^m=J^{m+1}=\cdots\)</span>。记 <span
class="math inline">\(I=J^m\)</span>。显然只要 <span
class="math inline">\(n\geqslant1\)</span> 就有 <span
class="math inline">\(I^n=I\)</span>。下面用反证法证明 <span
class="math inline">\(I=\{0\}\)</span>。</p>
<p>假设 <span class="math inline">\(I\neq\{0\}\)</span>。令 <span
class="math inline">\(\mathcal F\)</span> 为所有满足 <span
class="math inline">\(IB\neq\{0\}\)</span> 的左理想 <span
class="math inline">\(B\)</span> 构成的集合。<span
class="math inline">\(\mathcal F\)</span> 不为空集因为 <span
class="math inline">\(I\in\mathcal F\)</span>。<br />
由于 <span class="math inline">\(R\)</span> 是左 Artin 环，所以 <span
class="math inline">\(\mathcal F\)</span> 有一个极小元 <span
class="math inline">\(B_0\)</span>。选取 <span
class="math inline">\(b\in B_0\)</span> 使得 <span
class="math inline">\(Ib\neq\{0\}\)</span>，由于 <span
class="math inline">\(Ib\subset B_0\)</span> 而 <span
class="math inline">\(B_0\)</span> 是极小元，所以 <span
class="math inline">\(Ib=B_0\)</span>。<br />
由于 <span class="math inline">\(Ib=B_0\)</span>，所以存在 <span
class="math inline">\(x\in I\)</span> 使得 <span
class="math inline">\(xb=b\)</span>，即 <span
class="math inline">\((1-x)b=0\)</span>。由于 <span
class="math inline">\(x\in I\)</span> 从而 <span
class="math inline">\(x\in J\)</span>，所以 <span
class="math inline">\((1-x)\)</span> 有左逆 <span
class="math inline">\(u\)</span>，因此 <span
class="math inline">\(b=u(1-x)b=0\)</span>。这与 <span
class="math inline">\(Ib\neq\{0\}\)</span> 矛盾。</p>

    </div>
</div>
<p>(4)<span class="math inline">\(\,\)</span>意味着，左 Artin 环的
Jacobson 根是<strong>极大幂零理想</strong>。</p>
<h2 id="半单环的等价刻画">半单环的等价刻画</h2>
<p>根据定理 <a href="#Peirce" title="31">31</a>，半单环的结构为：</p>
<div id="semi-simple-ring-1" class="statement theorem plain">
<p><span class="statement-heading"><span class="statement-label">定理
34</span>.</span><span class="statement-spah"> </span><span
class="math inline">\(\,\!\)</span> 假设 <span
class="math inline">\(R\)</span> 是幺环，那么：<br />
(1)<span class="math inline">\(\quad\)</span><span
class="math inline">\(R\)</span>
是左半单环当且仅当存在一系列互相正交的幂等元 <span
class="math inline">\(e_i\)</span> 使得 <span
class="math inline">\(1=\sum_{i=1}^ne_i\)</span>，<span
class="math inline">\(I_i=Re_i\)</span> 是极小左理想，并且 <span
class="math inline">\(_RR=\displaystyle\bigoplus_{i=1}^nI_i\)</span>。<br />
(2)<span class="math inline">\(\quad\)</span>如果 <span
class="math inline">\(R\)</span> 是左半单的那么它一定是左 Artin 的与左
Noether 的（反过来未必）。</p>
</div>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        证明
    </div>
    <div class='spoiler-content'>
        <p>只证明 (2)。显然 (1) 中的 <span
class="math display">\[\displaystyle\bigoplus_{i=1}^nI_i\supset
\displaystyle\bigoplus_{i=2}^nI_i\supset
\displaystyle\bigoplus_{i=3}^nI_i\supset\cdots\supset\{0\}\]</span>
构成一个合成列，<a
href="#chain-condition-composition-series">有合成列的模都满足升降链条件</a>，因此它自然是左
Artin 和左 Noether 的。</p>

    </div>
</div>
<p>(2)<span
class="math inline">\(\,\)</span>意味着，在半单环中，Jacobson
根就是极大幂零理想。</p>
<p>半单环的另一个等价定义是：</p>
<p><span id="semi-simple-ring-2"></p>
<div id="semi-simple-ring-2" class="statement theorem plain">
<p><span class="statement-heading"><span class="statement-label">定理
35</span>.</span><span class="statement-spah"> </span><span
class="math inline">\(\,\!\)</span> 左 <span
class="math inline">\(R\)</span>-模是半单的当且仅当其任意一个子模 <span
class="math inline">\(N\)</span> 都有直和补，即存在一个 <span
class="math inline">\(N&#39;\)</span> 使得 <span
class="math inline">\(M=N\oplus N&#39;\)</span>。</p>
</div>
<p></span></p>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        证明
    </div>
    <div class='spoiler-content'>
        <p>“<span class="math inline">\(\Rightarrow\)</span>”：<span
class="math inline">\(\quad\)</span>假设 <span
class="math inline">\(M=\displaystyle\sum_{i\in I}S_i\)</span>，其中
<span class="math inline">\(S_i\)</span> 为单模。对于指标集 <span
class="math inline">\(J\)</span>，我们可以定义 <span
class="math inline">\(S_J:=\displaystyle\sum_{i\in J}S_i\)</span>。</p>
<p>所有满足 <span class="math inline">\(S_J\cap N=\{0\}\)</span> 的子模
<span class="math inline">\(S_J\)</span> 可以构成一个子模族。根据 Zorn
引理，这个子模族中存在一个极大元 <span
class="math inline">\(S_K\)</span>。如果只是考虑环 <span
class="math inline">\(R\)</span> 作为自己的左模，用 Noether
环的升链条件也能得到相同的结论。</p>
<p>我们来证明 <span class="math inline">\(M=S_K\oplus N\)</span>，因为
<span class="math inline">\(S_K\cap N=\{0\}\)</span>，只需要证明 <span
class="math inline">\(S_K+N=M\)</span>。这只需要证明对 <span
class="math inline">\(I\)</span> 中的每一个 <span
class="math inline">\(i\)</span> 都有 <span
class="math inline">\(S_i\subset S_K+N\)</span>。如果 <span
class="math inline">\(i\in K\)</span>，则显然成立，现在考虑 <span
class="math inline">\(i\notin K\)</span> 的情形。</p>
<p>在 <span class="math inline">\(i\notin K\)</span> 时，<span
class="math inline">\((S_K+S_i)\cap N\neq\{0\}\)</span>，因此可从 <span
class="math inline">\((S_K+S_i)\cap N\)</span> 中任取一个元素： <span
class="math display">\[s_K+s_i=b\neq 0.\]</span> 其中 <span
class="math inline">\(b\in N\)</span>，<span
class="math inline">\(s_K\in S_K\)</span>，<span
class="math inline">\(s_i\in S_i\)</span> 并且 <span
class="math inline">\(s_i\neq 0\)</span>。然后移项就能发现： <span
class="math display">\[s_i=b-s_k\in S_K+N.\]</span> 因此 <span
class="math inline">\(s_i\in S_i\cap(S_K+N)\)</span>。考虑到 <span
class="math inline">\(S_i\cap(S_K+N)\)</span> 是 <span
class="math inline">\(S_i\)</span> 的子模而 <span
class="math inline">\(S_i\)</span> 是单模，所以 <span
class="math inline">\(S_i\cap(S_K+N)=S_K+N\)</span>，这意味着 <span
class="math inline">\(S_i\subset S_K+N\)</span>。</p>
<hr />
<p>为了证明“<span
class="math inline">\(\Leftarrow\)</span>”，需要一个引理。</p>
<p>(引理)<span class="math inline">\(\quad\)</span>如果半单模 <span
class="math inline">\(M\)</span> 的子模 <span
class="math inline">\(N\neq\{0\}\)</span> 并且 <span
class="math inline">\(N\)</span> 不是单模，那么 <span
class="math inline">\(N\)</span> 一定有一个单子模。</p>
<p>从 <span class="math inline">\(N\)</span> 中任取一个非零元素 <span
class="math inline">\(b\)</span>。<span class="math inline">\(N\)</span>
中所有不含 <span class="math inline">\(b\)</span>
的子模构成一个子模族，根据 Zorn 引理，可以从中选出一个最大的子模 <span
class="math inline">\(C\)</span>，由于 <span
class="math inline">\(C\)</span> 也是 <span
class="math inline">\(M\)</span> 的子模，所以存在直和补 <span
class="math inline">\(C&#39;\)</span> 使得 <span
class="math inline">\(M=C\oplus C&#39;\)</span>。然后 <span
class="math inline">\(N=N\cap(C\oplus C&#39;)=C\oplus(C&#39;\cap
N)\)</span>。</p>
<p>现在证明 <span class="math inline">\(D:=C&#39;\cap N\)</span>
就是单模。如果 <span class="math inline">\(D\)</span> 不是单模，那么在
<span class="math inline">\(D\)</span> 中取一个含有 <span
class="math inline">\(b\)</span> 的子模 <span
class="math inline">\(H_1\)</span>，类似地，可以证明 <span
class="math inline">\(D=H_1\oplus H_2\)</span> 其中 <span
class="math inline">\(H_2=H_1&#39;\cap D\)</span>，<span
class="math inline">\(H_1&#39;\oplus H_1=M\)</span>。此时，<span
class="math inline">\(C\oplus H_2\)</span> 也是不含 <span
class="math inline">\(b\)</span> 的子模，这与 <span
class="math inline">\(C\)</span> 是 <span
class="math inline">\(N\)</span> 的不含 <span
class="math inline">\(b\)</span> 的子模中最大的一个相矛盾。</p>
<hr />
<p>“<span class="math inline">\(\Leftarrow\)</span>”的证明：所有由 <span
class="math inline">\(M\)</span> 的有限个单子模直和得来的 <span
class="math inline">\(M\)</span> 的子模构成一个子模族，由 Zorn
引理，其中存在一个极大元，将其记为 <span
class="math inline">\(U\)</span>。</p>
<p>此时，存在一个 <span class="math inline">\(V\)</span> 使得 <span
class="math inline">\(U\oplus V=M\)</span>。如果 <span
class="math inline">\(V\neq\{0\}\)</span>，那么 <span
class="math inline">\(V\)</span> 必然含有一个单子模 <span
class="math inline">\(W\)</span>，从而 <span
class="math inline">\(U\oplus W\)</span> 也是由 <span
class="math inline">\(M\)</span> 的有限个单子模直和得来的，这与 <span
class="math inline">\(U\)</span> 的极大性矛盾，因此 <span
class="math inline">\(V=\{0\}\)</span>。</p>
<p>这意味着 <span
class="math inline">\(M=U\)</span>，它是由有限个单子模直和得来的。</p>

    </div>
</div>
<p>半单环的另一个等价定义为以下定理中的 (2)：</p>
<div id="semi-simple-ring-4" class="statement theorem plain">
<p><span class="statement-heading"><span class="statement-label">定理
36</span>.</span><span class="statement-spah"> </span><span
class="math inline">\(\,\!\)</span><br />
(1)<span class="math inline">\(\quad\)</span>如果 <span
class="math inline">\(M\)</span> 是幺环 <span
class="math inline">\(R\)</span> 上的左半单模，那么 <span
class="math inline">\(M\)</span> 的左子模与商模也是左半单模。<br />
(2)<span class="math inline">\(\quad\)</span>假设 <span
class="math inline">\(R\)</span> 是幺环，那么 <span
class="math inline">\(R\)</span> 是左半单环当且仅当所有左 <span
class="math inline">\(R\)</span>-模都是左半单模。<br />
(3)<span class="math inline">\(\quad\)</span>假设幺环 <span
class="math inline">\(R\)</span> 是左半单环，<span
class="math inline">\(I\)</span> 是 <span
class="math inline">\(R\)</span> 的双边理想，那么 <span
class="math inline">\(R/I\)</span> 也是左半单环</p>
</div>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        证明
    </div>
    <div class='spoiler-content'>
        <p>(1)<span class="math inline">\(\quad\)</span>假设 <span
class="math inline">\(N\)</span> 是 <span
class="math inline">\(M\)</span> 的子模，任取 <span
class="math inline">\(N\)</span> 的子模 <span
class="math inline">\(B\)</span>，由于 <span
class="math inline">\(M\)</span> 是左半单的，所以 <span
class="math inline">\(M=B\oplus B&#39;\)</span>，进而 <span
class="math inline">\(N=B\oplus(B&#39;\cap N)\)</span>，即 <span
class="math inline">\(N\)</span> 的任意一个子模都有直和补，所以 <span
class="math inline">\(N\)</span> 是左半单的。</p>
<p>假设 <span class="math inline">\(N\)</span> 是 <span
class="math inline">\(M\)</span> 的子模，由于 <span
class="math inline">\(M\)</span> 是左半单的，所以 <span
class="math inline">\(M=N\oplus N&#39;\)</span>。这意味着 <span
class="math inline">\(M/N\simeq N&#39;\)</span>，而 <span
class="math inline">\(N&#39;\)</span> 是 <span
class="math inline">\(M\)</span> 的子模，它是左半单的，所以 <span
class="math inline">\(M/N\)</span> 是左半单的。</p>
<p>(2)<span class="math inline">\(\quad\)</span>“<span
class="math inline">\(\Leftarrow\)</span>”是显然的，考虑 <span
class="math inline">\(R\)</span> 做为自己的左模即可。然后考虑“<span
class="math inline">\(\Rightarrow\)</span>”。假设 <span
class="math inline">\(F\)</span> 是左半单环上的自由模，它同构于 <span
class="math inline">\(R\oplus\cdots\oplus R\)</span>，因此 <span
class="math inline">\(F\)</span> 是半单的。所有的左 <span
class="math inline">\(R\)</span>-模都可视为 <span
class="math inline">\(F\)</span> 的商模，因此所有的左 <span
class="math inline">\(R\)</span>-模都是半单模。</p>
<p>(3)<span class="math inline">\(\quad\)</span>将 <span
class="math inline">\(R\)</span> 视为自己的左模，<span
class="math inline">\(I\)</span> 就是它的左子模，因此 <span
class="math inline">\(R/I\)</span> 也是 <span
class="math inline">\(R\)</span> 上的左半单模。这意味着 <span
class="math inline">\(R/I\)</span> 可以写为 <span
class="math inline">\(R\)</span> 上的左单模 <span
class="math inline">\(S_i\)</span> 的直和。如果能证明 <span
class="math inline">\(S_i\)</span> 也是环 <span
class="math inline">\(R/I\)</span> 上的左单模，那么 <span
class="math inline">\(R/I\)</span> 就是左单环。</p>
<p>现在证明 <span class="math inline">\(S_i\)</span> 也是环 <span
class="math inline">\(R/I\)</span> 上的左单模。由于 <span
class="math inline">\(S_i\)</span> 中的元素都是商去 <span
class="math inline">\(I\)</span> 的等价类，所以 <span
class="math inline">\(IS_i=S_i\)</span>，这意味着 <span
class="math inline">\(R\)</span> 在 <span
class="math inline">\(S_i\)</span> 上的作用效果与 <span
class="math inline">\(R/I\)</span> 相同。如果 <span
class="math inline">\(S_i\)</span> 不是 <span
class="math inline">\(R/I\)</span> 上的左单模，那它也不会是 <span
class="math inline">\(R\)</span> 上的左单模，所以 <span
class="math inline">\(S_i\)</span> 也是环 <span
class="math inline">\(R/I\)</span> 上的左单模。</p>

    </div>
</div>
<p>半单环的判定方法为：</p>
<div id="semi-simple-ring-3" class="statement theorem plain">
<p><span class="statement-heading"><span class="statement-label">定理
37</span>.</span><span class="statement-spah"> </span><span
class="math inline">\(\,\!\)</span><br />
(1)<span class="math inline">\(\quad\)</span>幺环 <span
class="math inline">\(R\)</span> 是左半单环当且仅当 <span
class="math inline">\(R\)</span> 是左 Artin 的并且其 Jacobson 根 <span
class="math inline">\(J(R)=\{0\}\)</span>。<br />
(2)<span class="math inline">\(\quad\)</span>幺环 <span
class="math inline">\(R\)</span> 是左半单环当且仅当 <span
class="math inline">\(R\)</span> 是左 Artin 的并且其极大幂零理想为 <span
class="math inline">\(\{0\}\)</span>。</p>
</div>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        证明
    </div>
    <div class='spoiler-content'>
        <p>只需要证明 (1)。</p>
<p>“<span class="math inline">\(\Rightarrow\)</span>”：<span
class="math inline">\(\quad\)</span>只需证明 Jacobson 根 <span
class="math inline">\(J(R)=\{0\}\)</span>。由于 <span
class="math inline">\(J(R)\)</span> 是 <span
class="math inline">\(R\)</span> 的左理想，因而也是作为左模的 <span
class="math inline">\(R\)</span> 的子模，<a
href="#semi-simple-ring-2">因此</a>存在 <span
class="math inline">\(I\)</span> 使得 <span
class="math inline">\(R=J(R)\oplus I\)</span>。<a
href="#Peirce">这意味着</a>存在正交幂等元 <span
class="math inline">\(e,f\in R\)</span> 使得 <span
class="math inline">\(e+f=1\)</span>，并且 <span
class="math inline">\(Re=J(R)\)</span> 以及 <span
class="math inline">\(Rf=I\)</span>。由于 <span
class="math inline">\(e\in J(R)\)</span>，<a
href="#Jacobson-equivalence">所以</a> <span
class="math inline">\(1-e=f\)</span> 有逆元 <span
class="math inline">\(f^{-1}\)</span>，这意味着： <span
class="math display">\[f=1\cdot f=(f^{-1}\cdot f)\cdot
f=f^{-1}\cdot(f\cdot f)=f^{-1}\cdot f=1.\]</span> 所以 <span
class="math inline">\(e=0\)</span>，<span
class="math inline">\(J(R)=Re=\{0\}\)</span>。</p>
<hr />
<p>“<span class="math inline">\(\Leftarrow\)</span>”：<span
class="math inline">\(\quad\)</span>任取一个 <span
class="math inline">\(R\)</span> 的不为 <span
class="math inline">\(\{0\}\)</span> 的极小左理想 <span
class="math inline">\(I_1\)</span>，由于 <span
class="math inline">\(I\nsubseteq J(R)\)</span>，所以存在一个极大左理想
<span class="math inline">\(J_1\)</span> 使得 <span
class="math inline">\(I_1\nsubseteq J_1\)</span>，这意味着 <span
class="math inline">\(I_1+J_1=R\)</span>。再考虑 <span
class="math inline">\(I_1\cap J_1\)</span>，它是 <span
class="math inline">\(R\)</span> 的理想，并且是 <span
class="math inline">\(I_1\)</span> 的理想，因此 <span
class="math inline">\(I_1\cap J_1\)</span> 只有 <span
class="math inline">\(\{0\}\)</span> 和 <span
class="math inline">\(I_1\)</span> 两种可能。由于 <span
class="math inline">\(I_1\nsubseteq J_1\)</span>，所以 <span
class="math inline">\(I_1\cap J_1=\{0\}\)</span>，因此 <span
class="math inline">\(R=I_1\oplus J_1\)</span>。</p>
<p>由于 <span class="math inline">\(R\)</span> 是左 Artin
的，所以所有包含于 <span class="math inline">\(J_1\)</span>
的左理想中必有极小元，它一定也是极小左理想，将它记为 <span
class="math inline">\(I_2\)</span>。由于 <span
class="math inline">\(I_2\)</span> 也是极小左理想，所以存在一个左理想
<span class="math inline">\(J_2&#39;\)</span> 使得 <span
class="math inline">\(I_2\oplus J_2&#39;=R\)</span>。不难发现 <span
class="math inline">\(J_2:=J_2&#39;\cap J_1\)</span> 也是一个理想，并且
<span class="math inline">\(J_1=J_1\cap(I_2\oplus J_2&#39;)=I_2\oplus
J_2\)</span>。</p>
<p>根据以上过程，可以得到一系列的极小左理想 <span
class="math inline">\(I_i\)</span>，以及一系列的左理想 <span
class="math inline">\(J_i\)</span>，它们满足 <span
class="math inline">\(I_{i+1}\subset J_i\)</span>，并且 <span
class="math inline">\(J_i=I_{i+1}\oplus J_{i+1}\)</span>。可以看出 <span
class="math display">\[R=J_0\supsetneq J_1\supsetneq J_2\cdots\]</span>
构成一个理想的降链。由于 <span class="math inline">\(R\)</span> 是左
Artin 的，所以这一降链总会终止，并且只能终止于 <span
class="math inline">\(J_r=\{0\}\)</span>。这意味着 <span
class="math inline">\(R=I_1\oplus\cdots\oplus I_r\)</span>，因此 <span
class="math inline">\(R\)</span> 是半单的。</p>

    </div>
</div>
<p>最后，关于半单环有 Wedderburn-Artin
定理。这一定理的证明涉及到反环的概念：</p>
<div id="opposite-ring" class="statement definition plain">
<p><span class="statement-heading"><span class="statement-label">定义
29</span>.</span><span class="statement-spah"> </span><span
class="math inline">\(\,\!\)</span><strong>（反环）</strong><br />
将环 <span class="math inline">\(R\)</span> 中的乘法记为 <span
class="math inline">\(\mu\)</span>：<span
class="math inline">\(\mu(a,b)=ab\in R\)</span>。取 <span
class="math inline">\(R\)</span> 的全体元素，定义它们之间的加法为 <span
class="math inline">\(R\)</span> 上的加法，乘法为 <span
class="math inline">\(\mu^{\mathrm{op}}(a,b):=\mu(b,a)\)</span>，这样得到的环称为
<span class="math inline">\(R\)</span> 的<strong>反环（opposite
ring）</strong>，记为 <span
class="math inline">\(R^{\mathrm{op}}\)</span>。</p>
</div>
<p>不难想象，<span
class="math inline">\((R^{\mathrm{op}})^{\mathrm{op}}=R\)</span>，并且
<span class="math inline">\(R\)</span> 的左（右）模构成 <span
class="math inline">\(R^{\mathrm{op}}\)</span> 的右（左）模。<span
class="math inline">\(R=R^{\mathrm{op}}\)</span> 当且仅当 <span
class="math inline">\(R\)</span> 是交换环。此外还有：</p>
<div id="opposite-ring-and-End_R" class="statement theorem plain">
<p><span class="statement-heading"><span class="statement-label">定理
38</span>.</span><span class="statement-spah"> </span><span
class="math inline">\(\,\!\)</span> 将幺环 <span
class="math inline">\(R\)</span> 视为自己的左模，那么有环同构 <span
class="math inline">\(\mathrm{End}_R( _RR)\simeq
R^{\mathrm{op}}\)</span>。</p>
</div>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        证明
    </div>
    <div class='spoiler-content'>
        <p>考虑从 <span class="math inline">\(\mathrm{End}_R( _RR)\)</span> 到
<span class="math inline">\(R^{\mathrm{op}}\)</span> 的映射 <span
class="math inline">\(\varphi\)</span>： <span
class="math display">\[\varphi(f)=f(1).\]</span></p>
<p>不难验证 <span class="math inline">\(\varphi\)</span>
是一一映射，并且保持环的加法。考虑环的乘法：<span
class="math inline">\(\varphi(fg)=f(g(1))\)</span>，注意到 <span
class="math inline">\(g(1)=g(1)\cdot 1\)</span>，它可理解为 <span
class="math inline">\(g(1)\)</span> 在 <span
class="math inline">\(1\)</span> 上的环作用。由于 <span
class="math inline">\(f\)</span> 是环同态，所以： <span
class="math display">\[\varphi(fg)=f(g(1))=f(g(1)\cdot 1)=g(1)\cdot
f(1)=\varphi(g)\cdot\varphi(f).\]</span> 这样就证明了 <span
class="math inline">\(\varphi\)</span> 是环同态。</p>

    </div>
</div>
<p>然后是 Wedderburn-Artin 定理：</p>
<div id="Hom_R-oplus" class="statement theorem plain">
<p><span class="statement-heading"><span class="statement-label">定理
39</span>.</span><span class="statement-spah"> </span><span
class="math inline">\(\,\!\)</span> <strong>（Wedderburn-Artin
定理）</strong> 幺环 <span class="math inline">\(R\)</span>
是半单的当且仅当它同构于除环上矩阵代数的直和。</p>
</div>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        证明
    </div>
    <div class='spoiler-content'>
        <p>先证明一个小的引理：</p>
<p>(引理)<span class="math inline">\(\quad\)</span>假设 <span
class="math inline">\(R\)</span> 是幺环，<span
class="math inline">\(M_n(R)\)</span> 是 <span
class="math inline">\(R\)</span> 上的 <span
class="math inline">\(n\times n\)</span> 矩阵形成的环，那么 <span
class="math inline">\([M_n(R)]^{\mathrm{op}}\simeq
M_n(R^{\mathrm{op}})\)</span>。</p>
<p>考虑从 <span class="math inline">\([M_n(R)]^{\mathrm{op}}\)</span> 到
<span class="math inline">\(M_n(R^{\mathrm{op}})\)</span> 的映射 <span
class="math inline">\(T\)</span>，它将矩阵映射为矩阵的转置：<span
class="math inline">\(T(A)=A^{\mathrm T}\)</span>。我们用 <span
class="math inline">\(\ast\)</span> 表示反环中的运算：<span
class="math inline">\(a\ast b=ba\)</span>。假设 <span
class="math inline">\(A,B\in [M_n(R)]^{\mathrm{op}}\)</span>，于是：
<span class="math display">\[\begin{align*}
[T(A\ast
B)]_{ij}&amp;=[T(BA)]_{ij}=(BA)_{ji}=\sum_{k}B_{jk}A_{ki}=\sum_k(B^{\mathrm
T})_{kj}(A^{\mathrm T})_{ik}\\
&amp;=\sum_k(A^{\mathrm T})_{ik}\ast(B^{\mathrm T})_{kj}=[T(A)T(B)]_{ij}
\end{align*}\]</span> 所以 <span class="math inline">\(T\)</span>
保持乘法。不难验证它还保持加法，还是双射。因此是同构。</p>
<hr />
<p>首先证明“<span
class="math inline">\(\Rightarrow\)</span>”。我们先考虑 <span
class="math inline">\(\mathrm{End}_R(R)\)</span>。假设 <span
class="math inline">\(R\)</span> 可分解为一系列极小左理想的直和： <span
class="math display">\[R\simeq
\bigoplus_{i=1}^n\bigoplus_{j=1}^{n_i}I_{i,j},\]</span> 其中 <span
class="math inline">\(I_{i,1\sim n_i}\)</span> 彼此同构，并且在 <span
class="math inline">\(i&#39;\neq i\)</span> 时 <span
class="math inline">\(I_{i,j}\)</span> 与 <span
class="math inline">\(I_{i&#39;,j&#39;}\)</span> 不同构。</p>
<p>从 <span class="math inline">\(\mathrm{End}_R(R)\)</span>
中任取一个元素 <span
class="math inline">\(f\)</span>。然后考虑两类映射：<span
class="math inline">\(\alpha_{i,j}\)</span> 是将 <span
class="math inline">\(I_{i,j}\)</span> 中的元素映射为 <span
class="math inline">\(R\)</span> 中元素的包含映射，<span
class="math inline">\(p_{i,j}\)</span> 为将 <span
class="math inline">\(R\)</span> 中的元素映射为其 <span
class="math inline">\(I_{i,j}\)</span> 分量的投影映射。考虑一个将 <span
class="math inline">\(\mathrm{End}_R(R)\)</span>
中的元素映射为矩阵的映射 <span class="math inline">\(\varphi\)</span>：
<span
class="math display">\[[\varphi(f)]_{ij,i&#39;j&#39;}:=p_{ij}f\alpha_{i&#39;j&#39;}.\]</span>
不难证明： <span class="math display">\[\begin{align*}
[\varphi(f)\varphi(g)]_{i_1j_1,i_2j_2}&amp;=\sum_{i&#39;j&#39;}[\varphi(f)]_{i_1j_1,i&#39;j&#39;}[\varphi(g)]_{i&#39;j&#39;,i_2j_2}=\sum_{i&#39;j&#39;}p_{i_1j_1}f\alpha_{i&#39;j&#39;}p_{i&#39;j&#39;}g\alpha_{i_2j_2}\\
&amp;=p_{i_1j_1}fg\alpha_{i_2j_2}=[\varphi(fg)]_{i_1j_1,i_2j_2}.
\end{align*}\]</span> 因此这是一个从 <span
class="math inline">\(\mathrm{End}_R(R)\)</span>
到某个矩阵环的环同态，其中的矩阵元都是 <span
class="math inline">\(\mathrm{Hom}_R(I_{i,j},I_{i&#39;,j&#39;})\)</span>
中的映射。</p>
<p>可以证明，<span class="math inline">\(\varphi\)</span> 是环同构。</p>
<p>根据 Schur 引理，<span class="math inline">\(i\neq i&#39;\)</span> 时
<span
class="math inline">\(\mathrm{Hom}_R(I_{i,j},I_{i&#39;,j&#39;})=\{0\}\)</span>，因此：
<span class="math display">\[\mathrm{End}_R(R)\simeq\bigoplus_{i=1}^n
M_{n_i}(\mathrm{End}_R(I_i)),\]</span> 其中 <span
class="math inline">\(I_i\simeq I_{i,j}\)</span>，<span
class="math inline">\(M_n(R&#39;)\)</span> 意为环 <span
class="math inline">\(R&#39;\)</span> 上的 <span
class="math inline">\(n\times n\)</span> 矩阵环。根据 Schur 引理，<span
class="math inline">\(\mathrm{End}_R(I_i)\)</span> 是除环。</p>
<p>考虑到 <span class="math inline">\(\mathrm{End}_R(R)\simeq
R^{\text{op}}\)</span>，<span
class="math inline">\(R=(R^{\text{op}})^{\text{op}}\)</span>，<span
class="math inline">\([M_{n_i}(\mathrm{End}_R(I_i))]^{\mathrm{op}}\simeq
M_{n_i}([\mathrm{End}_R(I_i)]^{\mathrm{op}})\)</span>，除环的反环还是除环，所以
<span class="math inline">\(R\)</span>
必定同构于除环上的矩阵代数的直和。</p>
<hr />
<p>对于“<span
class="math inline">\(\Leftarrow\)</span>”，只需要证明除环上的矩阵代数是半单环即可。我们用
<span class="math inline">\(D\)</span> 表示除环，用 <span
class="math inline">\(M_n(D)\)</span> 表示除环上的 <span
class="math inline">\(n\times n\)</span> 矩阵环，用 <span
class="math inline">\(E_{ij}\)</span> 表示只有 <span
class="math inline">\(i\)</span> 行 <span
class="math inline">\(j\)</span> 列的矩阵元为 <span
class="math inline">\(1\)</span> 其余全为 <span
class="math inline">\(0\)</span> 的矩阵。</p>
<p>不难看出，仅有第 <span class="math inline">\(i\)</span> 列不为 <span
class="math inline">\(0\)</span> 的矩阵 <span
class="math inline">\(RE_{ii}\)</span> 构成 <span
class="math inline">\(M_n(D)\)</span> 的左理想，并且是极小左理想。由于
<span
class="math inline">\(M_n(D)\simeq\bigoplus_{i=1}^nRE_{ii}\)</span>，其中
<span class="math inline">\(E_{ii}\)</span> 是本原幂等元，因此 <span
class="math inline">\(M_n(D)\)</span> 是半单的。</p>

    </div>
</div>
<h2 id="群代数">群代数</h2>
<h1 id="参考书籍">参考书籍</h1>
<ul>
<li>《抽象代数<span class="math inline">\(\,\)</span>I –
代数学基础》孟道骥，陈良云，史毅茜，白瑞蒲.<span
class="math inline">\(\quad\)</span>北京：科学出版社，2010.</li>
<li>《抽象代数<span class="math inline">\(\,\)</span>II –
结合代数》孟道骥，王立云，史毅茜，徐立媛.<span
class="math inline">\(\quad\)</span>北京：科学出版社，2011.<br />
</li>
<li>《抽象代数<span
class="math inline">\(\,\)</span>I》赵春来，徐明曜.<span
class="math inline">\(\quad\)</span>北京：北京大学出版社，2008.<br />
</li>
<li>《代数学引论（第二版）》聂灵沼，丁石孙.<span
class="math inline">\(\quad\)</span>北京：高等教育出版社，2000.<br />
</li>
<li>《近世代数初步》石生明.<span
class="math inline">\(\quad\)</span>北京：高等教育出版社，2002.<br />
</li>
<li>《<a
target="_blank" rel="noopener" href="https://www.anandinstitute.org/pdf/Advanced%20Modern%20Algebra%20-%20Joseph%20J.%20Rotman.pdf">Advanced
Modern Algebra</a>》Joseph J. Rotman.</li>
<li><a target="_blank" rel="noopener" href="https://www.zhihu.com/column/c_1269028152392896512"><span
class="math inline">\(\;\;\)</span>抽象代数（知乎专栏）</a> – by
0003</li>
<li><a target="_blank" rel="noopener" href="https://www.zhihu.com/column/c_1207616756296134656"><span
class="math inline">\(\;\;\)</span>格罗卜的数学乐园（知乎专栏）</a> – by
格罗卜学数学</li>
</ul>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>
    </div>

    
    
    

    <footer class="post-footer">

        

          <div class="post-nav">
            <div class="post-nav-item">
            </div>
            <div class="post-nav-item">
                <a href="/2024/05/29/about_next/" rel="next" title="关于 hexo 与 next 的配置问题">
                  关于 hexo 与 next 的配置问题 <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2024</span>
    <span class="with-love">
      <i class="fa fa-ghost"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">XMQ</span>
  </div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/pisces/" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div><script color="0,0,255" opacity="0.5" zIndex="-1" count="99" src="https://cdn.jsdelivr.net/npm/canvas-nest.js@1/dist/canvas-nest.js"></script>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/sidebar.js"></script><script src="/js/next-boot.js"></script>

  






  




  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"ams","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script>
<script src="/js/third-party/math/mathjax.js"></script>



</body>
</html>
